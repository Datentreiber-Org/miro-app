<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Datentreiber – Template Mapper</title>
  <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 12px;
      font-size: 13px;
    }
    h3 {
      margin-top: 0;
      font-size: 15px;
    }
    h4 {
      margin: 8px 0 4px;
      font-size: 13px;
    }
    .block {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 8px;
    }
    button {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #f5f5f5;
      cursor: pointer;
      font-size: 12px;
      margin-right: 6px;
      margin-top: 4px;
    }
    button:hover {
      background: #eee;
    }
    label {
      display: block;
      margin: 4px 0;
    }
    input[type="password"],
    select,
    textarea {
      width: 100%;
      box-sizing: border-box;
      font-size: 12px;
      margin-top: 2px;
      padding: 4px;
    }
    textarea {
      resize: vertical;
    }
    .hint {
      color: #666;
      font-size: 11px;
      margin: 0 0 4px;
    }
    #log {
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px;
      white-space: pre-wrap;
      background: #fafafa;
      border: 1px solid #eee;
      border-radius: 6px;
      padding: 6px;
      max-height: 260px;
      overflow: auto;
    }
  </style>
</head>
<body>
  <div id="app">
    <h3>Datentreiber Bot Beta V.1.0</h3>

    <div class="block">
      <h4>1) Template wählen</h4>
      <p class="hint">
        Option A: „Template-Bild auf Board einfügen“ legt dein 3-Boxes-PNG als Bild aufs Board.<br>
        Option B: ein vorhandenes 3-Boxes-PNG auf dem Board auswählen (blau markiert)
        und dann „Aktuelle Auswahl als Template setzen“ klicken.<br>
        Beim Klassifizieren / GPT-Call werden alle aktuell ausgewählten 3-Boxes-PNGs
        als eigene Template-Instanzen berücksichtigt (1..n).
      </p>
      <button onclick="window.dtInsertTemplateImage()">Template-Bild auf Board einfügen</button>
      <button onclick="window.dtSetTemplateFromSelection()">Aktuelle Auswahl als Template setzen</button>
      <button onclick="window.dtClassifyStickies()">Stickies klassifizieren</button>
      <button onclick="window.dtClusterSelection()">Auswahl clustern (unterstrichener Text = Clustername)</button>

    </div>

    <div class="block">
      <h4>2) GPT-Abfrage</h4>
      <label>
        OpenAI API Key:
        <input id="api-key" type="password" placeholder="sk-..." autocomplete="off">
      </label>
      <label>
        Modell:
        <select id="model">
          <option value="gpt-4.1-mini">gpt-4.1-mini</option>
          <option value="gpt-4.1">gpt-4.1</option>
          <option value="o3-mini">o3-mini</option>
        </select>
      </label>
      <label>
        Frage / Aufgabe an GPT:
        <textarea id="user-text" rows="3"
          placeholder="Bitte analysiere die Sticky Notes auf dem 3-Boxes-Canvas ..."></textarea>
      </label>
      <button onclick="window.dtCallOpenAI()">An GPT senden (inkl. aktueller Klassifikation)</button>
    </div>

    <div class="block">
      <h4>Debug / Ausgabe</h4>
      <pre id="log"></pre>
    </div>
  </div>

  <script>
    // --------------------------------------------------------------------
    // Konfiguration
    // --------------------------------------------------------------------
    const TEMPLATE_ID = "datentreiber-3boxes";
    const TEMPLATE_IMAGE_URL =
      "https://www.datentreiber.com/wp-content/uploads/2024/12/Datentreiber_EN_3-Boxes_v1-1_20240610.png";
    const CLUSTER_META_KEY = "datentreiber-clusters";


    let currentTemplateImage = null;   // {id, title, x, y, width, height}
    let lastClassification = null;
    let miroReadyPromise = null;

    function log(msg) {
      const el = document.getElementById("log");
      const text = typeof msg === "string" ? msg : JSON.stringify(msg, null, 2);
      el.textContent = (el.textContent ? el.textContent + "\n\n" : "") + text;
      el.scrollTop = el.scrollHeight;
    }

    // Beim Laden sofort sichtbar machen, dass JS läuft:
    (function initialLog() {
      const el = document.getElementById("log");
      if (el) {
        el.textContent =
          "Panel-JS geladen: " + new Date().toLocaleTimeString() +
          "\nWarte auf Miro SDK (dtEnsureMiroReady) ...";
      }
      console.log("[DT] app.html Script geladen");
    })();

    window.onerror = function (msg, src, line, col, err) {
      log("JS-Fehler: " + msg + " @ " + line + ":" + col);
    };

    function stripHtml(html) {
      if (!html) return "";
      const tmp = document.createElement("div");
      tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || "";
    }
    
    // Unterstrichenen Text aus dem Sticky-HTML extrahieren (für Cluster-Namen)
    function dtExtractUnderlinedText(html) {
      if (!html) return null;
      const tmp = document.createElement("div");
      tmp.innerHTML = html;
      const u = tmp.querySelector("u");
      if (!u) return null;
      const txt = (u.textContent || "").trim();
      return txt || null;
    }

    // --------------------------------------------------------------------
    // Miro-Ready-Helfer (einmalig)
    // --------------------------------------------------------------------
    function dtEnsureMiroReady() {
      if (!miroReadyPromise) {
        miroReadyPromise = new Promise((resolve) => {
          if (window.miro && typeof window.miro.board !== "undefined") {
            console.log("[DT] Miro SDK v2 direkt verfügbar");
            log("Miro SDK bereit.");
            resolve();
          } else if (window.miro && typeof window.miro.onReady === "function") {
            window.miro.onReady(() => {
              console.log("[DT] miro.onReady fired");
              log("Miro SDK bereit (onReady).");
              resolve();
            });
          } else {
            log("Warnung: miro.onReady nicht verfügbar, versuche SDK direkt zu verwenden.");
            resolve();
          }
        });
      }
      return miroReadyPromise;
    }

    // --------------------------------------------------------------------
    // Template-Resolver: 1..n Bild-Instanzen bestimmen
    //  - 1. Priorität: ausgewählte 3-Boxes-PNGs (URL enthält TEMPLATE_IMAGE_URL)
    //  - 2. Priorität: zuletzt gemerkte Template-Instanz
    // --------------------------------------------------------------------
    async function dtResolveTemplateImages(options) {
      const silent = options && options.silent;
      await dtEnsureMiroReady();

      let selection = [];
      try {
        selection = await miro.board.getSelection();
      } catch (e) {
        if (!silent) {
          log("Fehler beim Lesen der Auswahl: " + e.message);
        }
      }

      // 1) Alle ausgewählten 3-Boxes-Bilder als Templates verwenden
      if (selection && selection.length) {
        const images = selection.filter(
          (item) =>
            item.type === "image" &&
            typeof item.url === "string" &&
            item.url.indexOf(TEMPLATE_IMAGE_URL) !== -1
        );

        if (images.length) {
          const templates = images.map((img) => ({
            id: img.id,
            title: img.title || "Datentreiber 3-Boxes",
            x: img.x,
            y: img.y,
            width: img.width,
            height: img.height
          }));

          // Für Abwärtskompatibilität: erste Instanz merken
          currentTemplateImage = templates[0];

          if (!silent) {
            if (templates.length === 1) {
              log(
                "Template aus Auswahl verwendet: Bild-ID " +
                templates[0].id + " / " + templates[0].title
              );
            } else {
              log(
                "Mehrere Template-Bilder aus Auswahl verwendet (" +
                templates.length + " Stück)."
              );
            }
          }
          return templates;
        }
      }

      // 2) Fallback: gespeichertes Template-Bild anhand seiner ID vom Board holen
      if (!currentTemplateImage || !currentTemplateImage.id) {
        if (!silent) {
          log(
            "Kein Template gesetzt und keine passende Bild-Auswahl vorhanden. " +
            "Bitte zuerst ein 3-Boxes-PNG einfügen oder auswählen."
          );
        }
        return [];
      }

      try {
        const arr = await miro.board.get({ id: currentTemplateImage.id });
        const img = Array.isArray(arr) ? arr[0] : arr;

        if (!img) {
          if (!silent) {
            log("Das gespeicherte Template-Bild existiert nicht mehr auf dem Board.");
          }
          return [];
        }

        const t = {
          id: img.id,
          title: img.title || currentTemplateImage.title || "Datentreiber 3-Boxes",
          x: img.x,
          y: img.y,
          width: img.width,
          height: img.height
        };

        currentTemplateImage = t;

        if (!silent) {
          log(
            "Template aus gespeicherter Referenz verwendet: Bild-ID " +
            t.id + " / " + t.title
          );
        }

        return [t];
      } catch (e) {
        if (!silent) {
          log("Fehler beim Laden des gespeicherten Template-Bildes: " + e.message);
        }
        return [];
      }
    }

    // --------------------------------------------------------------------
    // 1A) Template-Bild neu einfügen
    // --------------------------------------------------------------------
    async function dtInsertTemplateImage() {
      log("Button: Template-Bild auf Board einfügen (klick).");
      await dtEnsureMiroReady();

      try {
        const image = await miro.board.createImage({
          url: TEMPLATE_IMAGE_URL,
          x: 0,
          y: 0,
          width: 2000
        });

        currentTemplateImage = {
          id: image.id,
          title: image.title || "Datentreiber 3-Boxes",
          x: image.x,
          y: image.y,
          width: image.width,
          height: image.height
        };
        lastClassification = null;

        log(
          "Template eingefügt: Bild-ID " + image.id +
          " / " + currentTemplateImage.title +
          "\nDu kannst das Bild nun verschieben oder skalieren.\n" +
          "Wenn du mehrere Instanzen hast, kannst du eine oder mehrere " +
          "davon auswählen (blauer Rahmen) und dann klassifizieren / GPT senden."
        );
        await miro.board.viewport.zoomTo(image);
      } catch (e) {
        log("Fehler beim Einfügen des Template-Bildes: " + e.message);
      }
    }

    // --------------------------------------------------------------------
    // 1B) Template aus aktueller Auswahl setzen (manuelle Fokussierung)
    // --------------------------------------------------------------------
    async function dtSetTemplateFromSelection() {
      log("Button: Aktuelle Auswahl als Template setzen (klick).");
      await dtEnsureMiroReady();

      try {
        const selection = await miro.board.getSelection();
        if (!selection.length) {
          log("Kein Element ausgewählt. Bitte das Template-PNG auf dem Board anklicken (blau markiert) und erneut versuchen.");
          return;
        }

        const image = selection.find((item) => item.type === "image");
        if (!image) {
          log("In der Auswahl ist kein Bild-Element. Bitte direkt das Template-PNG auswählen (nicht den Frame).");
          return;
        }

        currentTemplateImage = {
          id: image.id,
          title: image.title || "Datentreiber 3-Boxes",
          x: image.x,
          y: image.y,
          width: image.width,
          height: image.height
        };
        lastClassification = null;

        log("Template gesetzt aus Auswahl: Bild-ID " + image.id +
            " / " + currentTemplateImage.title);
      } catch (e) {
        log("Fehler beim Setzen des Templates aus Auswahl: " + e.message);
      }
    }

    
    // --------------------------------------------------------------------
    // 1C) Auswahl clustern:
    //      - Auswahl muss Sticky Notes enthalten
    //      - erster Sticky mit unterstrichenem Text => Clustername
    //      - alle ausgewählten Stickies bekommen Metadaten mit Cluster-Name
    //        (Sticky kann immer nur in einem Cluster: Wert wird überschrieben)
    // --------------------------------------------------------------------
    async function dtClusterSelection() {
      log("Button: Auswahl clustern (klick).");
      await dtEnsureMiroReady();

      let selection = [];
      try {
        selection = await miro.board.getSelection();
      } catch (e) {
        log("Fehler beim Lesen der Auswahl für Clustering: " + e.message);
        return;
      }

      if (!selection || !selection.length) {
        log("Keine Elemente ausgewählt. Bitte die gewünschten Sticky Notes auswählen und erneut versuchen.");
        return;
      }

      const stickies = selection.filter(function (item) {
        return item.type === "sticky_note";
      });

      if (!stickies.length) {
        log("In der Auswahl sind keine Sticky Notes. Bitte mindestens zwei Sticky Notes auswählen.");
        return;
      }

      // Cluster-Header bestimmen: erster Sticky mit unterstrichenem Text
      let headerSticky = null;
      let clusterName = null;

      for (const s of stickies) {
        const name = dtExtractUnderlinedText(s.content);
        if (name) {
          headerSticky = s;
          clusterName = name;
          break;
        }
      }

      if (!headerSticky || !clusterName) {
        log(
          "Kein Sticky Note mit unterstrichenem Text gefunden. " +
          "Bitte einen Sticky im Cluster mit unterstrichenem Text als Clusternamen versehen."
        );
        return;
      }

      try {
        const updates = [];

        for (const s of stickies) {
          const allMeta = s.metadata || {};
          const existing = allMeta[CLUSTER_META_KEY] || {};

          // Sticky kann nur in einem Cluster sein: clusterName wird überschrieben
          const newClusterMeta = {
            ...existing,
            clusterName: clusterName,
            clusterHeaderId: headerSticky.id,
            isClusterHeader: s.id === headerSticky.id
          };

          const newMetadata = {
            ...allMeta,
            [CLUSTER_META_KEY]: newClusterMeta
          };

          updates.push(
            miro.board.update({
              id: s.id,
              metadata: newMetadata
            })
          );
        }

        await Promise.all(updates);

        log(
          'Cluster "' +
            clusterName +
            '" gesetzt für ' +
            stickies.length +
            " Sticky Notes (Header: " +
            stripHtml(headerSticky.content) +
            ")."
        );
      } catch (e) {
        log("Fehler beim Setzen der Cluster-Metadaten: " + e.message);
      }
    }

    // --------------------------------------------------------------------
    // Mapping von normalisierten Koordinaten -> Regionen (3 Boxen)
    // --------------------------------------------------------------------
    function dtMapToRegion(px, py) {
      // Vertikale Begrenzung grob: unterhalb des Headers, oberhalb Fußzeile
      const yMin = 0.20;
      const yMax = 0.95;
      if (py < yMin || py > yMax) return null;
      if (px < 0 || px > 1) return null;

      const third = 1 / 3;
      if (px < third) {
        return { id: "left",   title: "Box 1 (links)" };
      } else if (px < 2 * third) {
        return { id: "middle", title: "Box 2 (Mitte)" };
      } else {
        return { id: "right",  title: "Box 3 (rechts)" };
      }
    }

    // Sehr grob: Rolle aus Y-Position ableiten (Header / Body / Footer)
    function dtRoleFromNormalizedY(py) {
      if (py < 0.20) return "header";  // oberer Streifen über den drei Boxen
      if (py > 0.95) return "footer";  // unterer Streifen
      return "body";
    }

    // --------------------------------------------------------------------
    // 2a) Klassifikation für EIN Template (intern)
    //      - inkl. Farbe, Tags und Verbindungen
    // --------------------------------------------------------------------
    function dtClassifyStickiesForTemplate(template, ctx) {
      const t = template;
      const left = t.x - t.width / 2;
      const top  = t.y - t.height / 2;

      const result = {
        template: {
          id: TEMPLATE_ID,
          name: t.title,
          imageId: t.id,
          headerSummary: null
        },
        header: {
          stickies: []
        },
        counts: {
          total: 0,
          byRegion: {}
        },
        items: [],
        connections: []
      };

      const stickyMap = new Map();

      // --- Stickies einsammeln ------------------------------------------------
      for (const s of ctx.stickies) {
        const sx = s.x;
        const sy = s.y;

        const px = (sx - left) / t.width;
        const py = (sy - top) / t.height;
        const inImageRect = px >= 0 && px <= 1 && py >= 0 && py <= 1;

        if (!inImageRect) {
          // außerhalb dieses Template-Bildes -> ignorieren
          continue;
        }

        const role = dtRoleFromNormalizedY(py);

        let regionId = null;
        let regionTitle = null;
        if (role === "body") {
          const region = dtMapToRegion(px, py);
          if (region) {
            regionId = region.id;
            regionTitle = region.title;
          }
        }

        result.counts.total += 1;
        if (regionId) {
          result.counts.byRegion[regionId] =
            (result.counts.byRegion[regionId] || 0) + 1;
        }

        const cleanText = stripHtml(s.content);
        const color =
          (s.style && (s.style.fillColor || s.style.backgroundColor)) || null;
        const tagIds = Array.isArray(s.tagIds) ? s.tagIds.slice() : [];
        const tags =
          tagIds && tagIds.length && ctx.tagsById
            ? tagIds
                .map((id) => ({
                  id,
                  title: ctx.tagsById[id] || null
                }))
                .filter((t) => t.id)
            : [];

        const item = {
          stickyId: s.id,
          text: cleanText,
          px: Math.round(px * 10000) / 10000,
          py: Math.round(py * 10000) / 10000,
          inImageRect,
          role,
          regionId,
          regionTitle,
          color,
          tagIds,
          tags,
          connectionsOut: [],
          connectionsIn: []
        };

        result.items.push(item);
        stickyMap.set(s.id, item);

        if (role === "header") {
          result.header.stickies.push({
            stickyId: s.id,
            text: cleanText,
            px: item.px,
            py: item.py,
            color,
            tagIds,
            tags
          });
        }
      }

      // Header-Text grob zusammenfassen, damit jede Instanz identifizierbar ist
      if (result.header.stickies.length) {
        const pieces = result.header.stickies
          .map((h) => h.text)
          .filter(Boolean);
        if (pieces.length) {
          const joined = pieces.join(" | ");
          result.template.headerSummary =
            joined.length > 200 ? joined.slice(0, 197) + "..." : joined;
        }
      }

      // --- Connector-Beziehungen zwischen Stickies innerhalb dieses Templates
      if (ctx.connectors && ctx.connectors.length) {
        for (const c of ctx.connectors) {
          const startId = c.start && c.start.item;
          const endId   = c.end   && c.end.item;
          if (!startId || !endId) continue;

          const fromItem = stickyMap.get(startId);
          const toItem   = stickyMap.get(endId);
          if (!fromItem || !toItem) continue; // mind. ein Ende nicht in diesem Template

          const conn = {
            connectorId: c.id,
            fromStickyId: startId,
            toStickyId: endId
          };

          if (c.shape) {
            conn.shape = c.shape;
          }
          if (c.style) {
            const style = {};
            if (typeof c.style.startStrokeCap !== "undefined") {
              style.startStrokeCap = c.style.startStrokeCap;
            }
            if (typeof c.style.endStrokeCap !== "undefined") {
              style.endStrokeCap = c.style.endStrokeCap;
            }
            if (typeof c.style.strokeColor !== "undefined") {
              style.strokeColor = c.style.strokeColor;
            }
            if (Object.keys(style).length) {
              conn.style = style;
            }
          }

          result.connections.push(conn);
          fromItem.connectionsOut.push({
            connectorId: c.id,
            toStickyId: endId
          });
          toItem.connectionsIn.push({
            connectorId: c.id,
            fromStickyId: startId
          });
        }
      }

      return result;
    }

    // --------------------------------------------------------------------
    // 2b) Stickies klassifizieren (für 1..n Templates)
    //     - Kann manuell (Button) oder „silent“ aus dtCallOpenAI aufgerufen werden
    // --------------------------------------------------------------------
    async function dtClassifyStickies(options) {
      const silent = options && options.silent;
      if (!silent) {
        log("Button: Stickies klassifizieren (klick).");
      }

      await dtEnsureMiroReady();

      const templates = await dtResolveTemplateImages({ silent });
      if (!templates || !templates.length) {
        if (!silent) {
          log(
            "Es konnten keine Template-Bilder ermittelt werden. " +
            "Bitte wähle mindestens ein 3-Boxes-PNG aus oder füge eines ein."
          );
        }
        return null;
      }

      try {
        const [stickies, connectors, tags] = await Promise.all([
          miro.board.get({ type: "sticky_note" }),
          miro.board.get({ type: "connector" }),
          miro.board.get({ type: "tag" })
        ]);

        const tagsById = {};
        if (Array.isArray(tags)) {
          for (const tag of tags) {
            const title = tag.title || tag.text || tag.content || "";
            tagsById[tag.id] = title;
          }
        }

        const ctx = { stickies, connectors, tagsById };
        const results = templates.map((t) =>
          dtClassifyStickiesForTemplate(t, ctx)
        );

        lastClassification =
          results.length === 1 ? results[0] : { templates: results };

        if (!silent) {
          if (results.length === 1) {
            log("Klassifikation fertig (1 Template):");
            log(lastClassification);
          } else {
            log("Klassifikation fertig für " + results.length + " Templates:");
            log(lastClassification);
          }
        }

        return lastClassification;
      } catch (e) {
        if (!silent) {
          log("Fehler bei der Klassifikation: " + e.message);
        } else {
          console.error("[DT] Fehler bei der Klassifikation (silent):", e);
        }
        return null;
      }
    }


    // --------------------------------------------------------------------
    // 2c) Reduziertes JSON für das Sprachmodell aus der Klassifikation bauen
    // --------------------------------------------------------------------
    function dtBuildPromptPayloadFromClassification(classification) {
      if (!classification) {
        return null;
      }

      const perTemplate = Array.isArray(classification.templates) && classification.templates.length
        ? classification.templates
        : [classification];

      function transformOne(one) {
        const idToItem = {};
        if (Array.isArray(one.items)) {
          for (const item of one.items) {
            if (item && item.stickyId) {
              idToItem[item.stickyId] = item;
            }
          }
        }

        function buildConnectionsOut(item) {
          const result = [];
          if (!item || !Array.isArray(item.connectionsOut)) {
            return result;
          }
          for (const co of item.connectionsOut) {
            const target = co && idToItem[co.toStickyId];
            const toText = target ? target.text : null;
            const toArea = target
              ? (target.regionTitle || (target.role === "header" ? "Header" : null))
              : null;
            result.push({
              connectorId: co.connectorId,
              toText: toText,
              toArea: toArea
            });
          }
          return result;
        }

        function buildConnectionsIn(item) {
          const result = [];
          if (!item || !Array.isArray(item.connectionsIn)) {
            return result;
          }
          for (const ci of item.connectionsIn) {
            const source = ci && idToItem[ci.fromStickyId];
            const fromText = source ? source.text : null;
            const fromArea = source
              ? (source.regionTitle || (source.role === "header" ? "Header" : null))
              : null;
            result.push({
              connectorId: ci.connectorId,
              fromText: fromText,
              fromArea: fromArea
            });
          }
          return result;
        }

        const headerStickiesRaw =
          (one.header && Array.isArray(one.header.stickies) && one.header.stickies) || [];

        const header = {
          summary: one.template && one.template.headerSummary,
          stickies: headerStickiesRaw.map(function (h) {
            const item = h.stickyId ? idToItem[h.stickyId] : null;
            const tagObjs = item && Array.isArray(item.tags)
              ? item.tags
              : (Array.isArray(h.tags) ? h.tags : []);
            const tags = tagObjs
              .map(function (t) { return t && t.title; })
              .filter(function (title) { return !!title; });

            return {
              text: h.text,
              color: (item && item.color) || h.color || null,
              tags: tags,
              connectionsOut: buildConnectionsOut(item),
              connectionsIn: buildConnectionsIn(item)
            };
          })
        };

        const areasByName = {};

        if (Array.isArray(one.items)) {
          for (const item of one.items) {
            if (!item) {
              continue;
            }
            if (item.role === "header") {
              // Header-Stickies laufen separat unter "header"
              continue;
            }

            const areaName = item.regionTitle || "Ohne Area";
            if (!areasByName[areaName]) {
              areasByName[areaName] = {
                name: areaName,
                stickies: []
              };
            }

            const tags = Array.isArray(item.tags)
              ? item.tags
                  .map(function (t) { return t && t.title; })
                  .filter(function (title) { return !!title; })
              : [];

            const stickObj = {
              text: item.text,
              color: item.color || null,
              tags: tags,
              connectionsOut: buildConnectionsOut(item),
              connectionsIn: buildConnectionsIn(item)
            };

            areasByName[areaName].stickies.push(stickObj);
          }
        }

        const connectionsSummary = Array.isArray(one.connections)
          ? one.connections.map(function (c) {
              const fromItem = c.fromStickyId ? idToItem[c.fromStickyId] : null;
              const toItem = c.toStickyId ? idToItem[c.toStickyId] : null;

              const fromArea = fromItem
                ? (fromItem.regionTitle || (fromItem.role === "header" ? "Header" : null))
                : null;
              const toArea = toItem
                ? (toItem.regionTitle || (toItem.role === "header" ? "Header" : null))
                : null;

              return {
                connectorId: c.connectorId,
                fromText: fromItem ? fromItem.text : null,
                fromArea: fromArea,
                toText: toItem ? toItem.text : null,
                toArea: toArea
              };
            })
          : [];

        return {
          template: {
            name: one.template && one.template.name,
            headerSummary: one.template && one.template.headerSummary
          },
          header: header,
          areas: Object.keys(areasByName).map(function (key) {
            return areasByName[key];
          }),
          connections: connectionsSummary
        };
      }

      const templatesPayload = perTemplate.map(transformOne);

      return {
        templates: templatesPayload
      };
    }

    // --------------------------------------------------------------------
    // 3) OpenAI-Call mit aktueller Klassifikation
    //    - ruft intern zuerst dtClassifyStickies({ silent: true }) auf
    // --------------------------------------------------------------------
    async function dtCallOpenAI() {
      await dtEnsureMiroReady();

      const apiKey  = document.getElementById("api-key").value.trim();
      const model   = document.getElementById("model").value;
      const userText = document.getElementById("user-text").value.trim();

      if (!apiKey) {
        log("Bitte OpenAI API Key eingeben.");
        return;
      }
      if (!userText) {
        log("Bitte eine Frage / Aufgabe im Textfeld eingeben.");
        return;
      }

      // Immer vor dem GPT-Call frisch klassifizieren (aktueller Zustand,
      // inkl. aller aktuell ausgewählten Template-Instanzen).
      const classification = await dtClassifyStickies({ silent: true });

      // Reduziertes, modellfreundliches JSON aus der Klassifikation bauen
      const promptPayload = classification
        ? dtBuildPromptPayloadFromClassification(classification)
        : null;

      const classificationPart = promptPayload
        ? "\n\nAktuelle Sticky-Notiz-Klassifikation (reduziertes JSON für das Sprachmodell):\n" +
          JSON.stringify(promptPayload, null, 2)
        : "\n\nHinweis: Es liegt noch keine Klassifikation vor (kein Template gesetzt " +
          "oder keine Stickies innerhalb der Templates).";

      const fullUserText = userText + classificationPart;


      const body = {
        model,
        input: [
          {
            role: "system",
            content: [
              {
                type: "input_text",
                text:
                  "Du bist ein Assistent, der Miro-Boards analysiert. " +
                  "Du bekommst Sticky-Notes als JSON und eine Nutzerfrage " +
                  "und sollst exakte Antworten liefern. " +
                  "Antworte standardmäßig auf Deutsch."
              }
            ]
          },
          {
            role: "user",
            content: [
              {
                type: "input_text",
                text: fullUserText
              }
            ]
          }
        ],
        max_output_tokens: 10000
      };

      try {
        log("Sende Anfrage an OpenAI ...");
        const res = await fetch("https://api.openai.com/v1/responses", {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + apiKey,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        });

        const text = await res.text();
        if (!res.ok) {
          log("Fehler bei OpenAI-Anfrage: " + res.status + " " + text);
          return;
        }

        const data = JSON.parse(text);
        const firstMessage = data.output && data.output[0];
        const contentArr = firstMessage && firstMessage.content;
        const textPart = contentArr && contentArr.find((c) => c.type === "output_text");
        const answer = textPart ? textPart.text : "(keine Antwort gefunden)";

        log("Antwort von OpenAI:");
        log(answer);
      } catch (e) {
        log("Exception beim Aufruf der OpenAI API: " + e.message);
      }
    }

    // Funktionen ins window hängen, damit die inline-onclicks sie sehen
    window.dtInsertTemplateImage        = dtInsertTemplateImage;
    window.dtSetTemplateFromSelection   = dtSetTemplateFromSelection;
    window.dtClassifyStickies           = dtClassifyStickies;
    window.dtCallOpenAI                 = dtCallOpenAI;
    window.dtClusterSelection           = dtClusterSelection;

  </script>
</body>
</html>
