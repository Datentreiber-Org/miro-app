<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Datentreiber 3-Boxes – Miro Panel</title>
  <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 13px;
      margin: 0;
      padding: 8px;
      color: #111827;
    }
    h1 {
      font-size: 16px;
      margin: 0 0 8px 0;
    }
    label {
      font-weight: 500;
    }
    input[type="text"],
    input[type="password"],
    select,
    textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 4px 6px;
      margin-top: 2px;
      margin-bottom: 6px;
      border-radius: 4px;
      border: 1px solid #d1d5db;
      font-size: 12px;
      font-family: inherit;
    }
    textarea {
      min-height: 60px;
      resize: vertical;
    }
    button {
      font-size: 12px;
      padding: 4px 8px;
      margin: 2px 4px 4px 0;
      border-radius: 4px;
      border: 1px solid #d1d5db;
      background: #f3f4f6;
      cursor: pointer;
    }
    button:hover {
      background: #e5e7eb;
    }
    #log {
      margin-top: 8px;
      height: 260px;
      border-radius: 4px;
      border: 1px solid #e5e7eb;
      padding: 6px;
      background: #f9fafb;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      white-space: pre-wrap;
      overflow: auto;
    }
    .row {
      margin-bottom: 6px;
    }
    .btn-row {
      margin-top: 4px;
      margin-bottom: 6px;
    }
  </style>
</head>
<body>
  <h1>Datentreiber 3-Boxes – Panel</h1>

  <div class="row">
    <label for="api-key">OpenAI API Key</label>
    <input type="password" id="api-key" placeholder="sk-..." />
  </div>

  <div class="row">
    <label for="model">Modell</label>
    <select id="model">
      <option value="gpt-4.1-mini">gpt-4.1-mini</option>
      <option value="gpt-4.1">gpt-4.1</option>
      <option value="gpt-4o-mini">gpt-4o-mini</option>
      <option value="gpt-4o">gpt-4o</option>
    </select>
  </div>

  <div class="row">
    <label for="user-text">Frage / Aufgabe für den Agenten (Modus B)</label>
    <textarea id="user-text" placeholder="Was soll der Agent mit der ausgewählten Canvas-Instanz tun?"></textarea>
  </div>

  <div class="btn-row">
    <button onclick="dtInsertTemplateImage()">Template-Bild einfügen</button>
  </div>

  <div class="btn-row">
    <button onclick="dtClusterSelection()">Auswahl clustern (Side-Panel)</button>
    <button onclick="dtClassifyStickies()">Stickies klassifizieren (Debug)</button>
    <button onclick="dtCallOpenAI()">Klassischer OpenAI-Call</button>
  </div>

  <pre id="log"></pre>

  <script>
  // --------------------------------------------------------------------
  // Konfiguration
  // --------------------------------------------------------------------
  const TEMPLATE_ID = "datentreiber-3boxes";
  const TEMPLATE_IMAGE_URL =
    "https://www.datentreiber.com/wp-content/uploads/2024/12/Datentreiber_EN_3-Boxes_v1-1_20240610.png";
  const CLUSTER_META_KEY = "datentreiber-clusters";

  // Canvas-Definitions (Image-Maps) auf Polygonbasis, normalisierte Koordinaten (0..1)
  const DT_CANVAS_DEFS = {
    [TEMPLATE_ID]: {
      originalWidth: 4550,
      originalHeight: 3219,
      // Header-Bereich (oberer Streifen)
      headerPolygons: [
        {
          id: "header",
          title: "Header",
          polygonNorm: [
            [0.0, 0.0],
            [1.0, 0.0],
            [1.0, 0.18],
            [0.0, 0.18]
          ]
        }
      ],
      // Footer-Bereich (unterer Streifen)
      footerPolygons: [
        {
          id: "footer",
          title: "Footer",
          polygonNorm: [
            [0.0, 0.95],
            [1.0, 0.95],
            [1.0, 1.0],
            [0.0, 1.0]
          ]
        }
      ],
      // Drei Boxen im Body als echte Polygone (rechteckig, aber generische Polygon-Struktur)
      regionPolygons: [
        {
          id: "left",
          title: "Box 1 (links)",
          polygonNorm: [
            [0.0, 0.18],
            [1.0 / 3.0, 0.18],
            [1.0 / 3.0, 0.95],
            [0.0, 0.95]
          ]
        },
        {
          id: "middle",
          title: "Box 2 (Mitte)",
          polygonNorm: [
            [1.0 / 3.0, 0.18],
            [2.0 / 3.0, 0.18],
            [2.0 / 3.0, 0.95],
            [1.0 / 3.0, 0.95]
          ]
        },
        {
          id: "right",
          title: "Box 3 (rechts)",
          polygonNorm: [
            [2.0 / 3.0, 0.18],
            [1.0, 0.18],
            [1.0, 0.95],
            [2.0 / 3.0, 0.95]
          ]
        }
      ]
    }
  };

  // Instanz-Management (alle 3-Boxes-Bilder auf dem Board)
  let currentTemplateImage = null;   // {id, title, x, y, width, height} (Legacy/Fallback)
  let lastClassification = null;
  let miroReadyPromise = null;

  let dtInitialized = false;
  let dtNextInstanceCounter = 1;

  // Globaler Baseline-Status für den globalen Agenten (Modus A)
  let dtHasGlobalBaseline = false;

  // imageId -> instance
  // instanceId -> instance
  const dtInstancesByImageId = new Map();
  const dtInstancesById = new Map();

  // Cluster-Zuordnung: Sticky-ID -> Cluster-Name (nur Panel-Session)
  const dtClusterAssignments = new Map();

  // Schutzflag, um rekursive selection:update-Events zu vermeiden
  let dtHandlingSelection = false;

  // Automatische Cluster-Namen (Fallback), Zähler pro Instanz
  const dtClusterCounterByInstanceId = new Map();
  let dtGlobalClusterCounter = 1; // Reserve

  // Globale Kurz-ID-Zählung für Sticky-Aliasse (S0001, S0002, ...)
  let dtNextStickyAliasIndex = 1;

  // Letzte ID-Alias-Tabelle für Agent-Actions (Alias -> echte Sticky-ID)
  let dtLastAliasMap = null;

  // Letzte Auswahl von Sticky Notes (für den Cluster-Button auf dem Board)
  let dtLastStickySelectionIds = [];

  // Letzte Auswahl von Canvas-Instanzen (Frames oder Template-Bilder) für Modus B
  let dtLastCanvasSelectionInstanceIds = [];

  // Globaler Zwischenspeicher: Sticky -> owning Instance (Eindeutigkeits-Invariante)
  let dtStickyOwnerCache = new Map();

  // *** Echtzeit-/On-Demand-Live-Katalog ***
  // 1:1 Abbild des Boards:
  // Canvas-Typ -> Instanzen -> Regionen -> Stickies
  const dtLiveCatalog = {
    // canvasTypeId -> { canvasTypeId, instances: { [instanceId]: LiveInstance } }
    canvasTypes: Object.create(null),
    // instanceId -> LiveInstance (bequemer Flat-Index auf dieselben Objekte)
    instances: Object.create(null),
    // Stickies, die auf keinem Canvas liegen (z.B. frei herum auf dem Board)
    unassignedStickies: [],
    lastFullRebuildAt: null
  };


  // Sehr einfacher Prompt-Katalog für Modus B (instanzspezifisch)
  const DT_PROMPT_CATALOG = {
    [TEMPLATE_ID]: {
      system: (
        "Du bist ein Facilitation-Bot für Miro-Workshops.\n" +
        "Du siehst:\n" +
        "- eine oder mehrere Canvas-Instanzen (3-Boxes-Canvas) mit Sticky Notes als JSON\n" +
        "- einen Board-Katalog mit allen weiteren Instanzen (nur als Zusammenfassung).\n" +
        "Du sollst:\n" +
        "1) die Situation auf den übergebenen Instanzen verstehen (Input / Processing / Output),\n" +
        "2) sinnvolle nächste Schritte vorschlagen und\n" +
        "3) optionale Board-Aktionen als JSON liefern (z.B. Stickies verschieben oder anlegen).\n" +
        "Jede Sticky Note in den Strukturen unter 'activeCanvasState' bzw. 'activeCanvasStates' hat eine kurze ID im Feld 'id' (z.B. \"S1\"). " +
        "Wenn du eine Sticky Note in einer Action referenzierst, verwende genau diese kurze ID im Feld 'stickyId'.\n" +
        "WICHTIG: Antworte ausschließlich mit einem JSON-Objekt im folgenden Format:\n" +
        "{\n" +
        '  "analysis": "kurze Erklärung in natürlicher Sprache",\n' +
        '  "actions": [\n' +
        '    { "type": "move_sticky", "stickyId": "S1", "targetArea": "Box 2 (Mitte)" },\n' +
        '    { "type": "create_sticky", "area": "Box 3 (rechts)", "text": "Neuer Inhalt" },\n' +
        '    { "type": "delete_sticky", "stickyId": "S2" }\n' +
        "  ]\n" +
        "}\n" +
        "Falls du keine Aktionen vorschlagen möchtest, setze actions auf ein leeres Array []."
      )
    }
  };

  // System-Prompt für globalen Agenten-Modus A
  const DT_GLOBAL_SYSTEM_PROMPT = (
    "Du bist ein Facilitation-Bot für Miro-Workshops mit globalem Überblick über alle Canvas-Instanzen.\n" +
    "Du siehst:\n" +
    "- einen Board-Katalog mit allen Instanzen (boardCatalog)\n" +
    "- detaillierte JSON-Daten zu allen aktiven Instanzen (activeCanvasStates)\n" +
    "- optionale Changes seit dem letzten Agent-Run (activeInstanceChangesSinceLastAgent).\n" +
    "Analysiere die Gesamtsituation auf dem Board, schlage sinnvolle nächste Schritte vor und formuliere bei Bedarf Board-Aktionen als JSON.\n" +
    "Wenn du einzelne Sticky Notes in Actions referenzierst, verwende die Kurz-IDs aus den JSON-Strukturen.\n" +
    "Antworte ausschließlich mit einem JSON-Objekt mit den Feldern \"analysis\" und \"actions\"."
  );

  // --------------------------------------------------------------------
  // Logging & Helper
  // --------------------------------------------------------------------
  function log(msg) {
    const el = document.getElementById("log");
    const text = typeof msg === "string" ? msg : JSON.stringify(msg, null, 2);
    el.textContent = (el.textContent ? el.textContent + "\n\n" : "") + text;
    el.scrollTop = el.scrollHeight;
  }

  (function initialLog() {
    const el = document.getElementById("log");
    if (el) {
      el.textContent =
        "Panel-JS geladen: " + new Date().toLocaleTimeString() +
        "\nWarte auf Miro SDK (dtEnsureMiroReady) ...";
    }
    console.log("[DT] app.html Script geladen");
  })();

  window.onerror = function (msg, src, line, col, err) {
    log("JS-Fehler: " + msg + " @ " + line + ":" + col);
  };

  function stripHtml(html) {
    if (!html) return "";
    const tmp = document.createElement("div");
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || "";
  }

  function dtExtractUnderlinedText(html) {
    if (!html) return null;
    const tmp = document.createElement("div");
    tmp.innerHTML = html;
    const u = tmp.querySelector("u");
    if (!u) return null;
    const txt = (u.textContent || "").trim();
    return txt || null;
  }

  function dtGetCurrentUserQuestion() {
    const el = document.getElementById("user-text");
    const t = el && el.value ? el.value.trim() : "";
    if (t) return t;
    return "Bitte analysiere diese Canvas-Instanz und führe sinnvolle nächste Schritte innerhalb des Workshop-Workflows aus.";
  }

  // Canvas-Definition holen
  function dtGetCanvasDef(canvasTypeId) {
    return DT_CANVAS_DEFS[canvasTypeId] || null;
  }

  // Punkt-in-Polygon-Test (Even-Odd-Regel) für normalisierte Koordinaten
  function dtPointInPolygonNorm(px, py, polygonNorm) {
    let inside = false;
    const n = polygonNorm.length;
    if (n < 3) return false;
    for (let i = 0, j = n - 1; i < n; j = i++) {
      const xi = polygonNorm[i][0];
      const yi = polygonNorm[i][1];
      const xj = polygonNorm[j][0];
      const yj = polygonNorm[j][1];

      const intersect =
        (yi > py) !== (yj > py) &&
        px < ((xj - xi) * (py - yi) / ((yj - yi) || 1e-9)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }

  // Klassifizierung eines normalisierten Punktes anhand der Canvas-Definition
  function dtClassifyNormalizedLocation(canvasTypeId, px, py) {
    const def = dtGetCanvasDef(canvasTypeId);
    if (!def) {
      // Fallback auf alte, einfache Logik
      const role = dtRoleFromNormalizedY(py);
      let regionId = null;
      let regionTitle = null;
      if (role === "body") {
        const region = dtMapToRegion(px, py);
        if (region) {
          regionId = region.id;
          regionTitle = region.title;
        }
      }
      return { role, regionId, regionTitle };
    }

    // Header zuerst prüfen
    if (Array.isArray(def.headerPolygons)) {
      for (const h of def.headerPolygons) {
        if (dtPointInPolygonNorm(px, py, h.polygonNorm)) {
          return {
            role: "header",
            regionId: null,
            regionTitle: h.title || "Header"
          };
        }
      }
    }

    // Footer
    if (Array.isArray(def.footerPolygons)) {
      for (const f of def.footerPolygons) {
        if (dtPointInPolygonNorm(px, py, f.polygonNorm)) {
          return {
            role: "footer",
            regionId: null,
            regionTitle: f.title || "Footer"
          };
        }
      }
    }

    // Body-Regionen
    if (Array.isArray(def.regionPolygons)) {
      for (const r of def.regionPolygons) {
        if (dtPointInPolygonNorm(px, py, r.polygonNorm)) {
          return {
            role: "body",
            regionId: r.id,
            regionTitle: r.title
          };
        }
      }
    }

    // Innerhalb des PNG, aber keiner expliziten Region zugeordnet
    return {
      role: "body",
      regionId: null,
      regionTitle: null
    };
  }

  // --------------------------------------------------------------------
  // Miro-Ready-Helfer
  // --------------------------------------------------------------------
  function dtEnsureMiroReady() {
    if (!miroReadyPromise) {
      miroReadyPromise = new Promise((resolve) => {
        const onReady = () => {
          console.log("[DT] Miro SDK v2 bereit");
          log("Miro SDK bereit.");
          dtAfterMiroReady();
          resolve();
        };

        if (window.miro && typeof window.miro.board !== "undefined") {
          onReady();
        } else if (window.miro && typeof window.miro.onReady === "function") {
          window.miro.onReady(onReady);
        } else {
          log("Warnung: miro.onReady nicht verfügbar, versuche SDK direkt zu verwenden.");
          dtAfterMiroReady();
          resolve();
        }
      });
    }
    return miroReadyPromise;
  }

  async function dtAfterMiroReady() {
    if (dtInitialized) return;
    dtInitialized = true;

    try {
      await dtScanTemplateInstances();
    } catch (e) {
      console.error("[DT] Fehler beim initialen Template-Scan:", e);
    }

    try {
      if (miro.board && miro.board.ui && typeof miro.board.ui.on === "function") {
        // AI-Shape-Button reagieren lassen
        miro.board.ui.on("selection:update", dtOnSelectionUpdate);
      }
    } catch (e) {
      console.error("[DT] Fehler bei Registrierung von UI-Events:", e);
      log("Fehler bei Registrierung von UI-Events: " + e.message);
    }
  }

  // --------------------------------------------------------------------
  // Instanz-Management
  // --------------------------------------------------------------------
  async function dtCreateInstanceActionShapes(instance, image) {
    if (!miro.board) {
      return;
    }

    const hasCreateShape = typeof miro.board.createShape === "function";
    const hasCreateText = typeof miro.board.createText === "function";
    const hasCreateFrame = typeof miro.board.createFrame === "function";

    if (!hasCreateShape || !hasCreateFrame) {
      return;
    }

    // Frame so anlegen, dass das Canvas-Bild sowie Buttons und Eingabefeld
    // gemeinsam verschiebbar sind.
    const frameWidth = image.width + 200;
    const frameHeight = image.height + 260;
    const frameY = image.y + 80;

    const frame = await miro.board.createFrame({
      title: image.title || "Datentreiber 3-Boxes",
      x: image.x,
      y: frameY,
      width: frameWidth,
      height: frameHeight
    });

    const baseY = image.y + image.height / 2 + 80;
    const baseX = image.x;
    const dx = 260;
    const buttonWidth = 260;
    const buttonHeight = 60;

    // AI-Button (Send to OpenAI, Modus B)
    const aiShape = await miro.board.createShape({
      content: "Send to OpenAI",
      shape: "round_rectangle",
      x: baseX - dx,
      y: baseY,
      width: buttonWidth,
      height: buttonHeight
    });

    // Cluster-Button
    const clusterShape = await miro.board.createShape({
      content: "Cluster",
      shape: "round_rectangle",
      x: baseX,
      y: baseY,
      width: buttonWidth,
      height: buttonHeight
    });

    // Globaler Agent-Button (Modus A)
    const globalAgentShape = await miro.board.createShape({
      content: "Global Agent",
      shape: "round_rectangle",
      x: baseX + dx,
      y: baseY,
      width: buttonWidth,
      height: buttonHeight
    });

    // Globales Eingabefeld
    let globalInput = null;
    if (hasCreateText) {
      globalInput = await miro.board.createText({
        content: "",
        x: baseX + dx,
        y: baseY + buttonHeight + 40
      });
    }

    try {
      await frame.add(image);
      await frame.add(aiShape);
      await frame.add(clusterShape);
      await frame.add(globalAgentShape);
      if (globalInput) {
        await frame.add(globalInput);
      }
      await frame.sync();
    } catch (e) {
      console.error("[DT] Fehler beim Hinzufügen der Items zum Frame:", e);
    }

    instance.actionItems = {
      aiItemId: aiShape.id,
      clusterItemId: clusterShape.id,
      globalAgentItemId: globalAgentShape.id,
      globalAgentInputItemId: globalInput ? globalInput.id : null,
      frameId: frame.id
    };
  }

  // Versucht nach einem Board-Scan bestehende Frames/Buttons wieder mit Instanzen zu verknüpfen.
// Voraussetzung: Instanzen wurden bereits aus den Template-Bildern registriert.
async function dtRebindActionShapesAfterScan(images) {
  if (!miro.board) {
    return;
  }

  let shapes = [];
  let textItems = [];

  try {
    shapes = await miro.board.get({ type: "shape" }) || [];
    textItems = await miro.board.get({ type: "text" }) || [];
  } catch (e) {
    log("Fehler bei Rebind der Action-Shapes: " + e.message);
    return;
  }

  // Hilfs-Maps: parentId -> Items
  const shapesByParent = new Map();
  shapes.forEach(function (s) {
    const pid = s.parentId;
    if (!pid) {
      return;
    }
    if (!shapesByParent.has(pid)) {
      shapesByParent.set(pid, []);
    }
    shapesByParent.get(pid).push(s);
  });

  const textsByParent = new Map();
  textItems.forEach(function (t) {
    const pid = t.parentId;
    if (!pid) {
      return;
    }
    if (!textsByParent.has(pid)) {
      textsByParent.set(pid, []);
    }
    textsByParent.get(pid).push(t);
  });

  // Mapping: imageId -> echtes Image-Objekt
  const imageById = new Map();
  if (Array.isArray(images)) {
    images.forEach(function (img) {
      imageById.set(img.id, img);
    });
  }

  // Mapping: imageId -> frameId (über parentId)
  const frameIdByImageId = new Map();
  imageById.forEach(function (img, imgId) {
    if (img.parentId) {
      frameIdByImageId.set(imgId, img.parentId);
    }
  });

  // Für jede registrierte Instanz versuchen wir, die Action-Shapes zu finden
  dtInstancesByImageId.forEach(function (instance, imageId) {
    const img = imageById.get(imageId);
    if (!img) {
      return;
    }

    const frameId = frameIdByImageId.get(imageId);
    if (!frameId) {
      return;
    }

    const frameShapes = shapesByParent.get(frameId) || [];
    const frameTexts = textsByParent.get(frameId) || [];

    let aiShape = null;
    let clusterShape = null;
    let globalShape = null;
    let globalInput = null;

    // Buttons im Frame anhand ihres Inhalts erkennen
    frameShapes.forEach(function (s) {
      const raw = (s.content || "").toLowerCase();
      if (!aiShape && raw.indexOf("send to openai") !== -1) {
        aiShape = s;
      } else if (!clusterShape && raw.indexOf("cluster") !== -1) {
        clusterShape = s;
      } else if (!globalShape && raw.indexOf("global agent") !== -1) {
        globalShape = s;
      }
    });

    // Ein Text-Item im Frame als Global-Agent-Input verwenden (Heuristik: erstes)
    if (frameTexts.length > 0) {
      globalInput = frameTexts[0];
    }

    if (aiShape || clusterShape || globalShape || globalInput) {
      instance.actionItems = {
        aiItemId: aiShape ? aiShape.id : null,
        clusterItemId: clusterShape ? clusterShape.id : null,
        globalAgentItemId: globalShape ? globalShape.id : null,
        globalAgentInputItemId: globalInput ? globalInput.id : null,
        frameId: frameId
      };
      log("Action-Shapes re-gebunden für Instanz " + instance.instanceId);
    }
  });
}


  async function dtRegisterInstanceFromImage(image, options) {
    if (!image || !image.id) return null;

    options = options || {};
    const createActionShapes = options.createActionShapes !== false;

    let instance = dtInstancesByImageId.get(image.id);
    if (instance) {
      instance.title = image.title || instance.title || "Datentreiber 3-Boxes";
      instance.lastGeometry = {
        x: image.x,
        y: image.y,
        width: image.width,
        height: image.height
      };
      return instance;
    }

    const instanceId = "inst-" + (dtNextInstanceCounter++);
    instance = {
      instanceId,
      canvasTypeId: TEMPLATE_ID,
      imageId: image.id,
      title: image.title || "Datentreiber 3-Boxes",
      lastGeometry: {
        x: image.x,
        y: image.y,
        width: image.width,
        height: image.height
      },
      lastClassification: null,
      lastStateJson: null,
      lastStickyCount: 0,
      lastChangedAt: null,
      lastDiff: null,
      baselineClassification: null,
      baselineStateJson: null,
      lastAgentRunAt: null,
      actionItems: {},
      liveCatalog: null
    };
  
    // NEU: Wenn das Template-Bild bereits in einem Frame liegt
    // (z.B. durch Kopieren eines bestehenden Canvas-Frames),
    // dann merken wir uns diesen Frame als frameId der Instanz.
    if (!createActionShapes && image.parentId) {
      try {
        const parentArr = await miro.board.get({ id: image.parentId });
        const parent = Array.isArray(parentArr) ? parentArr[0] : parentArr;
        if (parent && parent.type === "frame") {
          instance.actionItems.frameId = parent.id;
        }
      } catch (e) {
        console.error("[DT] Konnte Eltern-Frame für Template-Image nicht laden:", e);
      }
    }
  
    dtInstancesByImageId.set(image.id, instance);
    dtInstancesById.set(instanceId, instance);
  
    log("Neue Canvas-Instanz registriert: " + instanceId + " (Bild-ID " + image.id + ")");
  
    if (createActionShapes) {
      try {
        await dtCreateInstanceActionShapes(instance, image);
      } catch (e) {
        console.error("[DT] Fehler beim Erzeugen der Action-Shapes:", e);
      }
    }
  
    return instance;
  }


  async function dtScanTemplateInstances() {
    if (!miro.board || !miro.board.get) {
      return;
    }
  
    let images = [];
    try {
      images = await miro.board.get({ type: "image" });
    } catch (e) {
      console.error("[DT] Fehler beim Laden der Images:", e);
      return;
    }
    if (!Array.isArray(images)) {
      return;
    }
  
    const templateImageIdsOnBoard = new Set();
  
    for (const img of images) {
      if (
        img.type === "image" &&
        typeof img.url === "string" &&
        img.url.indexOf(TEMPLATE_IMAGE_URL) !== -1
      ) {
        templateImageIdsOnBoard.add(img.id);
        await dtRegisterInstanceFromImage(img, { createActionShapes: false });
      }
    }
  
    const knownImageIds = Array.from(dtInstancesByImageId.keys());
    for (const imageId of knownImageIds) {
      if (!templateImageIdsOnBoard.has(imageId)) {
        const inst = dtInstancesByImageId.get(imageId);
        dtInstancesByImageId.delete(imageId);
        if (inst) {
          dtInstancesById.delete(inst.instanceId);
          log(
            "Canvas-Instanz entfernt (Template-Bild gelöscht): " +
            inst.instanceId +
            " (Bild-ID " +
            imageId +
            ")"
          );
        }
      }
    }
  
    // Nach dem Scan versuchen, bestehende Frames/Buttons mit den Instanzen zu verknüpfen,
    // damit nach Panel-Neustart die Buttons wieder funktionieren.
    try {
      await dtRebindActionShapesAfterScan(images);
    } catch (e) {
      console.error("[DT] Fehler beim Rebind der Action-Shapes:", e);
    }
  }

  // Eine Instanz gilt als "geändert", wenn sich Text, Area-Name, Farbe,
  // Tags oder Cluster-Zuordnung von Stickies verändert haben oder Stickies
  // hinzugekommen bzw. entfernt wurden.
  function dtDiffHasChanges(diff) {
    if (!diff) {
      return false;
    }
    const createdCount = Array.isArray(diff.created) ? diff.created.length : 0;
    const deletedCount = Array.isArray(diff.deleted) ? diff.deleted.length : 0;
    const updatedCount = Array.isArray(diff.updated) ? diff.updated.length : 0;
    return createdCount > 0 || deletedCount > 0 || updatedCount > 0;
  }

  // Board-Katalog-Summary mit Modi (global / instance / generic)
  function dtBuildBoardCatalogSummary(options) {
    options = options || {};
    const activeInstanceId = options.activeInstanceId || null;
    const mode = options.mode || "generic"; // "global" oder "instance"
    const hasGlobalBaseline =
      typeof options.hasGlobalBaseline === "boolean"
        ? options.hasGlobalBaseline
        : dtHasGlobalBaseline;

    const instances = [];
    dtInstancesById.forEach((instance, id) => {
      const diff = instance.lastDiff;
      const hasChanges = dtDiffHasChanges(diff);

      let changesSummary = null;
      if (hasChanges && diff) {
        const shouldSummarize = !(mode === "global" && !hasGlobalBaseline);
        if (shouldSummarize) {
          changesSummary = {
            createdCount: Array.isArray(diff.created) ? diff.created.length : 0,
            deletedCount: Array.isArray(diff.deleted) ? diff.deleted.length : 0,
            updatedCount: Array.isArray(diff.updated) ? diff.updated.length : 0
          };
        }
      }

      const headerSummary =
        instance.lastClassification &&
        instance.lastClassification.template &&
        instance.lastClassification.template.headerSummary
          ? instance.lastClassification.template.headerSummary
          : null;

      let isActive;
      if (mode === "global") {
        if (!hasGlobalBaseline) {
          isActive = true;
        } else {
          isActive = hasChanges;
        }
      } else {
        isActive = (id === activeInstanceId) || hasChanges;
      }

      const entry = {
        instanceId: id,
        canvasTypeId: instance.canvasTypeId,
        lastStickyCount: instance.lastStickyCount || 0,
        headerSummary: headerSummary,
        isActive: isActive,
        changesSinceLastAgent: changesSummary
      };
      instances.push(entry);
    });
    return { instances };
  }

  function dtFindInstanceForPoint(x, y) {
    let foundInstance = null;

    dtInstancesById.forEach(function (instance) {
      const geom = instance.lastGeometry;
      if (!geom) {
        return;
      }

      const left = geom.x - geom.width / 2;
      const top = geom.y - geom.height / 2;
      const right = geom.x + geom.width / 2;
      const bottom = geom.y + geom.height / 2;

      if (x >= left && x <= right && y <= bottom && y >= top) {
        if (!foundInstance) {
          foundInstance = instance;
        }
      }
    });

    return foundInstance;
  }

  async function dtOnSelectionUpdate(event) {
    if (dtHandlingSelection) {
      return;
    }

    const items = event && event.items ? event.items : [];

    const stickyIdsInSelection = items
      .filter(function (it) { return it.type === "sticky_note"; })
      .map(function (it) { return it.id; });

    if (stickyIdsInSelection.length > 0) {
      dtLastStickySelectionIds = stickyIdsInSelection.slice();
    }

    const canvasInstanceIdSet = new Set();
    items.forEach(function (it) {
      if (it.type === "image") {
        const inst = dtInstancesByImageId.get(it.id);
        if (inst) {
          canvasInstanceIdSet.add(inst.instanceId);
        }
      }
      if (it.type === "frame") {
        dtInstancesById.forEach(function (inst) {
          if (inst.actionItems && inst.actionItems.frameId === it.id) {
            canvasInstanceIdSet.add(inst.instanceId);
          }
        });
      }
    });
    if (canvasInstanceIdSet.size > 0) {
      dtLastCanvasSelectionInstanceIds = Array.from(canvasInstanceIdSet);
    }

    if (items.length !== 1) {
      return;
    }

    const item = items[0];
    if (item.type !== "shape") {
      return;
    }

    let instanceId = null;
    let buttonType = null;

    dtInstancesById.forEach(function (inst, id) {
      if (!inst.actionItems) return;
      if (inst.actionItems.aiItemId === item.id) {
        instanceId = id;
        buttonType = "ai";
      } else if (inst.actionItems.clusterItemId === item.id) {
        instanceId = id;
        buttonType = "cluster";
      } else if (inst.actionItems.globalAgentItemId === item.id) {
        instanceId = id;
        buttonType = "global";
      }
    });

    if (!instanceId || !buttonType) {
      return;
    }

    dtHandlingSelection = true;
    try {
      if (buttonType === "ai") {
        log("Agent-Button (Shape, Modus B) für Instanz " + instanceId + " ausgelöst.");
        await dtRunAgentForInstance(instanceId);
      } else if (buttonType === "cluster") {
        if (!dtLastStickySelectionIds || !dtLastStickySelectionIds.length) {
          log("Cluster-Button: Keine vorherige Sticky-Auswahl gefunden. Bitte zuerst Sticky Notes auswählen.");
          return;
        }
        log("Cluster-Button (Shape) für Instanz " + instanceId + " ausgelöst.");
        await dtClusterSelectionWithIds(dtLastStickySelectionIds, instanceId);
      } else if (buttonType === "global") {
        const inst = dtInstancesById.get(instanceId);
        if (!inst || !inst.actionItems || !inst.actionItems.globalAgentInputItemId) {
          log("Global-Button: Kein zugehöriges Eingabefeld gefunden.");
        } else {
          try {
            const arr = await miro.board.get({ id: inst.actionItems.globalAgentInputItemId });
            const textItem = Array.isArray(arr) ? arr[0] : arr;
            let userText = "";
            if (textItem && typeof textItem.content === "string") {
              userText = textItem.content.trim();
            }
            if (!userText) {
              userText = "Bitte gib einen globalen Überblick über alle relevanten Canvas-Instanzen und schlage sinnvolle nächste Schritte vor.";
            }
            log("Global-Agent-Button (Shape, Modus A) für Instanz " + instanceId + " ausgelöst.");
            await dtRunGlobalAgent(instanceId, userText);
          } catch (e) {
            log("Fehler beim Lesen des globalen Eingabefeldes: " + e.message);
          }
        }
      }
    } finally {
      dtHandlingSelection = false;
    }
  }

  // --------------------------------------------------------------------
  // Mapping von normalisierten Koordinaten -> Regionen (Fallback)
  // --------------------------------------------------------------------
  function dtMapToRegion(px, py) {
    const yMin = 0.20;
    const yMax = 0.95;
    if (py < yMin || py > yMax) return null;
    if (px < 0 || px > 1) return null;

    const third = 1 / 3;
    if (px < third) {
      return { id: "left",   title: "Box 1 (links)" };
    } else if (px < 2 * third) {
      return { id: "middle", title: "Box 2 (Mitte)" };
    } else {
      return { id: "right",  title: "Box 3 (rechts)" };
    }
  }

  function dtAreaNameToRegion(areaName) {
    if (!areaName) return null;
    const norm = areaName.toLowerCase();
    if (norm.indexOf("box 1") !== -1 || norm.indexOf("links") !== -1) {
      return { id: "left", title: "Box 1 (links)" };
    }
    if (norm.indexOf("box 2") !== -1 || norm.indexOf("mitte") !== -1) {
      return { id: "middle", title: "Box 2 (Mitte)" };
    }
    if (norm.indexOf("box 3") !== -1 || norm.indexOf("rechts") !== -1) {
      return { id: "right", title: "Box 3 (rechts)" };
    }
    return null;
  }

  function dtRoleFromNormalizedY(py) {
    if (py < 0.20) return "header";
    if (py > 0.95) return "footer";
    return "body";
  }

  // --------------------------------------------------------------------
  // Board-Kontext (für Live-Katalog, Klassifikation & Agent)
  // --------------------------------------------------------------------
  async function dtGetBoardBaseContext() {
    await dtEnsureMiroReady();
    try {
      const [stickies, connectors, tags] = await Promise.all([
        miro.board.get({ type: "sticky_note" }),
        miro.board.get({ type: "connector" }),
        miro.board.get({ type: "tag" })
      ]);

      const tagsById = {};
      if (Array.isArray(tags)) {
        for (const tag of tags) {
          const title = tag.title || tag.text || tag.content || "";
          tagsById[tag.id] = title;
        }
      }
      return { stickies: stickies || [], connectors: connectors || [], tagsById };
    } catch (e) {
      log("Fehler beim Laden des Board-Kontexts: " + e.message);
      return { stickies: [], connectors: [], tagsById: {} };
    }
  }

  // --------------------------------------------------------------------
  // 1A) Template-Bild neu einfügen
  // --------------------------------------------------------------------
  async function dtInsertTemplateImage() {
    log("Button: Template-Bild auf Board einfügen (klick).");
    await dtEnsureMiroReady();

    try {
      const image = await miro.board.createImage({
        url: TEMPLATE_IMAGE_URL,
        x: 0,
        y: 0,
        width: 2000
      });

      currentTemplateImage = {
        id: image.id,
        title: image.title || "Datentreiber 3-Boxes",
        x: image.x,
        y: image.y,
        width: image.width,
        height: image.height
      };
      lastClassification = null;

      await dtRegisterInstanceFromImage(image);

      log(
        "Template eingefügt: Bild-ID " + image.id +
        " / " + currentTemplateImage.title +
        "\nDu kannst das Bild nun verschieben oder skalieren.\n" +
        "Unterhalb des Canvas findest du die Buttons innerhalb eines Frames:\n" +
        "- Send to OpenAI – startet den Agenten für diese Instanz (Modus B)\n" +
        "- Cluster – clustert die zuvor ausgewählte Sticky-Auswahl innerhalb dieses Canvas\n" +
        "- Global Agent – startet den globalen Agenten (Modus A) mit dem Text aus dem zugehörigen Eingabefeld\n" +
        "\nAlternativ kannst du auch den Button 'Auswahl clustern' im Side-Panel verwenden. " +
        "Alle Varianten wirken nur auf Sticky Notes innerhalb genau einer Canvas-Instanz."
      );
      await miro.board.viewport.zoomTo(image);
    } catch (e) {
      log("Fehler beim Einfügen des Template-Bildes: " + e.message);
    }
  }



  // --------------------------------------------------------------------
  // Auswahl clustern
  // --------------------------------------------------------------------
  async function dtClusterSelectionWithIds(stickyIds, expectedInstanceId) {
    await dtEnsureMiroReady();
    await dtScanTemplateInstances();

    try {
      let stickyNotes = [];

      if (Array.isArray(stickyIds) && stickyIds.length > 0) {
        const arr = await miro.board.get({ id: stickyIds });
        if (Array.isArray(arr)) {
          stickyNotes = arr.filter(function (it) { return it.type === "sticky_note"; });
        } else if (arr && arr.type === "sticky_note") {
          stickyNotes = [arr];
        }
      } else {
        const selection = await miro.board.getSelection();
        if (!selection || !selection.length) {
          log("Keine Auswahl gefunden. Bitte einige Sticky Notes auswählen.");
          return;
        }
        stickyNotes = selection.filter(function (item) { return item.type === "sticky_note"; });
      }

      if (!stickyNotes.length) {
        log("In der Auswahl sind keine Sticky Notes. Bitte nur Sticky Notes auswählen.");
        return;
      }

      const byInstance = {};
      const outside = [];

      const expectedInstance = expectedInstanceId ? dtInstancesById.get(expectedInstanceId) : null;
      const expectedFrameId =
        expectedInstance && expectedInstance.actionItems
          ? expectedInstance.actionItems.frameId
          : null;

      stickyNotes.forEach(function (s) {
        let instance = null;

        if (expectedInstance && expectedFrameId && s.parentId === expectedFrameId) {
          instance = expectedInstance;
        } else {
          instance = dtFindInstanceForPoint(s.x, s.y);
        }

        if (!instance) {
          outside.push(s);
          return;
        }

        const id = instance.instanceId;
        if (!byInstance[id]) {
          byInstance[id] = [];
        }
        byInstance[id].push(s);
      });

      const instanceIds = Object.keys(byInstance);

      if (!instanceIds.length) {
        log(
          "Keine der ausgewählten Sticky Notes liegt über einem 3-Boxes-Canvas. " +
          "Bitte zuerst das Template verwenden und die Sticky Notes innerhalb des Canvas platzieren."
        );
        return;
      }

      if (instanceIds.length > 1) {
        log(
          "Die Auswahl enthält Sticky Notes aus mehreren Canvas-Instanzen. " +
          "Bitte nur Sticky Notes aus genau einer Instanz gleichzeitig clustern."
        );
        return;
      }

      const instanceId = instanceIds[0];

      if (expectedInstanceId && instanceId !== expectedInstanceId) {
        log(
          "Cluster-Button gehört zu einem anderen Canvas als die aktuelle Sticky-Auswahl. " +
          "Bitte nur Sticky Notes innerhalb desselben Canvas (bzw. desselben Frames) auswählen."
        );
        return;
      }

      const notesInInstance = byInstance[instanceId];

      if (outside.length > 0) {
        log(
          "Hinweis: Die Auswahl enthält Sticky Notes, die nicht über einem 3-Boxes-Canvas liegen. " +
          "Sie werden trotzdem dem gewählten Cluster zugeordnet."
        );
      }

      let headerSticky = null;
      for (const s of notesInInstance) {
        const html = s.content || "";
        if (
          html.indexOf("<u>") !== -1 ||
          html.indexOf("text-decoration:underline") !== -1
        ) {
          headerSticky = s;
          break;
        }
      }

      let clusterName = null;

      if (headerSticky) {
        const candidate = stripHtml(headerSticky.content).trim();
        if (!candidate) {
          log(
            "Der unterstrichene Sticky-Text ist leer. " +
            "Bitte einen lesbaren Namen unterstreichen oder ohne Unterstreichung arbeiten, " +
            "dann wird ein generischer Clustername vergeben."
          );
          return;
        }
        clusterName = candidate;
      } else {
        let count = dtClusterCounterByInstanceId.get(instanceId) || 0;
        count += 1;
        dtClusterCounterByInstanceId.set(instanceId, count);
        clusterName = "Cluster " + count;
      }

      for (const s of notesInInstance) {
        dtClusterAssignments.set(s.id, clusterName);
      }

      if (outside.length > 0) {
        for (const s of outside) {
          dtClusterAssignments.set(s.id, clusterName);
        }
      }

      const totalCount = notesInInstance.length + outside.length;

      log(
        "Cluster '" +
        clusterName +
        "' gesetzt für " +
        totalCount +
        " Sticky Notes (Session-State, kein Board-Metafeld)."
      );
    } catch (e) {
      log("Fehler beim Setzen der Cluster-Metadaten: " + e.message);
    }
  }

  async function dtClusterSelection() {
    log("Button: Auswahl clustern (klick).");
    await dtClusterSelectionWithIds(null);
  }

  // --------------------------------------------------------------------
  // *** NEU: Live-Katalog aus dem Boardzustand aufbauen ***
  // --------------------------------------------------------------------
  async function dtRebuildLiveCatalog(ctx) {
    await dtEnsureMiroReady();
    await dtScanTemplateInstances();

    if (!ctx) {
      ctx = await dtGetBoardBaseContext();
    }

    dtLiveCatalog.canvasTypes = Object.create(null);
    dtLiveCatalog.instances = Object.create(null);
    dtLiveCatalog.unassignedStickies = [];
    dtLiveCatalog.lastFullRebuildAt = new Date().toISOString();
    dtStickyOwnerCache = new Map();


    // Instanzliste + Geometrie vorbereiten
    const instList = [];
    dtInstancesById.forEach((inst) => instList.push(inst));

    const geomList = [];
    for (const inst of instList) {
      const geom = await dtComputeTemplateGeometry(inst);
      geomList.push({ inst, geom });
    }

    const instGeom = new Map();
    for (const entry of geomList) {
      if (entry.geom) {
        instGeom.set(entry.inst.instanceId, entry.geom);
      }
    }

    // NEU: Frame-ID -> Instanz (für Zuordnung über parentId)
    const frameIdToInstance = new Map();
    dtInstancesById.forEach((inst) => {
      if (inst.actionItems && inst.actionItems.frameId) {
        frameIdToInstance.set(inst.actionItems.frameId, inst);
      }
    });

    function ensureLiveInstance(inst) {
      let live = dtLiveCatalog.instances[inst.instanceId];
      if (!live) {
        live = {
          instanceId: inst.instanceId,
          canvasTypeId: inst.canvasTypeId,
          imageId: inst.imageId,
          geometry: instGeom.get(inst.instanceId) || null,
          regions: {
            header: { stickies: [] },
            footer: { stickies: [] },
            body: {
              left:  { stickies: [] },
              middle:{ stickies: [] },
              right: { stickies: [] },
              none:  { stickies: [] }  // im PNG, aber keiner definierten Region
            }
          },
          allStickies: [],
          connections: [],
          meta: {
            stickyCount: 0,
            connectorCount: 0,
            lastUpdated: null
          }
        };

        // Flat-Index
        dtLiveCatalog.instances[inst.instanceId] = live;

        // Hierarchischer Index: Canvas-Typ -> Instanzen
        const ctId = inst.canvasTypeId || TEMPLATE_ID;
        if (!dtLiveCatalog.canvasTypes[ctId]) {
          dtLiveCatalog.canvasTypes[ctId] = {
            canvasTypeId: ctId,
            instances: Object.create(null)
          };
        }
        dtLiveCatalog.canvasTypes[ctId].instances[inst.instanceId] = live;
      }
      return live;
    }


    // Stickies auf Instanzen + Regionen verteilen
    for (const s of ctx.stickies || []) {
      if (typeof s.x !== "number" || typeof s.y !== "number") continue;

      // 1) Primär: Zuordnung über parentId (Frame)
      let owningInst = null;
      if (s.parentId && frameIdToInstance.has(s.parentId)) {
        owningInst = frameIdToInstance.get(s.parentId);
      }

      // 2) Fallback: Geometrie-basierte Zuordnung (Bounding Box / nächstes Canvas)
      if (!owningInst) {
        let bestInst = null;
        let bestDistSq = Infinity;

        for (const entry of geomList) {
          const inst = entry.inst;
          const geom = entry.geom;
          if (!geom) continue;

          const left  = geom.x - geom.width  / 2;
          const top   = geom.y - geom.height / 2;
          const right = geom.x + geom.width  / 2;
          const bottom= geom.y + geom.height / 2;

          if (s.x >= left && s.x <= right && s.y >= top && s.y <= bottom) {
            const dx = s.x - geom.x;
            const dy = s.y - geom.y;
            const distSq = dx*dx + dy*dy;
            if (distSq < bestDistSq) {
              bestDistSq = distSq;
              bestInst = inst;
            }
          }
        }

        owningInst = bestInst;
      }

      if (!owningInst) {
        dtLiveCatalog.unassignedStickies.push(s.id);
        continue;
      }

      const geom = instGeom.get(owningInst.instanceId);
      if (!geom) {
        dtLiveCatalog.unassignedStickies.push(s.id);
        continue;
      }

      const left = geom.x - geom.width / 2;
      const top  = geom.y - geom.height / 2;
      const px   = (s.x - left) / geom.width;
      const py   = (s.y - top)  / geom.height;

      if (px < 0 || px > 1 || py < 0 || py > 1) {
        // Sicherstellen, dass wir wirklich im PNG sind
        dtLiveCatalog.unassignedStickies.push(s.id);
        continue;
      }

      const canvasTypeId = owningInst.canvasTypeId;
      const loc = dtClassifyNormalizedLocation(canvasTypeId, px, py);
      const role       = loc.role;
      const regionId   = loc.regionId || null;
      const regionTitle= loc.regionTitle || null;

      const color =
        (s.style && (s.style.fillColor || s.style.backgroundColor)) || null;

      const tagIds = Array.isArray(s.tagIds) ? s.tagIds : [];
      const tags = tagIds
        .map((id) => ctx.tagsById[id])
        .filter(Boolean);

      const clusterName = dtClusterAssignments.get(s.id) || null;

      const stickObj = {
        id: s.id,
        text: stripHtml(s.content),
        px: Math.round(px * 10000) / 10000,
        py: Math.round(py * 10000) / 10000,
        role,
        regionId,
        regionTitle,
        color,
        tags,
        clusterName,
        connectionsOut: [],
        connectionsIn: []
      };

      const liveInst = ensureLiveInstance(owningInst);
      if (role === "header") {
        liveInst.regions.header.stickies.push(stickObj);
      } else if (role === "footer") {
        liveInst.regions.footer.stickies.push(stickObj);
      } else {
        const key =
          regionId === "left" || regionId === "middle" || regionId === "right"
            ? regionId
            : "none";
        liveInst.regions.body[key].stickies.push(stickObj);
      }

      liveInst.allStickies.push(stickObj);
      dtStickyOwnerCache.set(s.id, owningInst.instanceId);
    }


    // Konnektoren pro Instanz zuordnen
    const stickyToInst = new Map();
    Object.values(dtLiveCatalog.instances).forEach((liveInst) => {
      liveInst.allStickies.forEach((st) => {
        stickyToInst.set(st.id, liveInst.instanceId);
      });
    });

    for (const c of ctx.connectors || []) {
      const fromId = c.start && c.start.item;
      const toId   = c.end   && c.end.item;
      if (!fromId || !toId) continue;

      const instFrom = stickyToInst.get(fromId);
      const instTo   = stickyToInst.get(toId);
      if (!instFrom || instFrom !== instTo) {
        // Cross-Instance optional separat
        continue;
      }

      const liveInst = dtLiveCatalog.instances[instFrom];
      if (!liveInst) continue;

      const conn = {
        connectorId: c.id,
        fromStickyId: fromId,
        toStickyId: toId
      };
      liveInst.connections.push(conn);
    }

    // Meta aktualisieren
    Object.values(dtLiveCatalog.instances).forEach((liveInst) => {
      liveInst.meta.stickyCount = liveInst.allStickies.length;
      liveInst.meta.connectorCount = liveInst.connections.length;
      liveInst.meta.lastUpdated = dtLiveCatalog.lastFullRebuildAt;
    });

    // Live-Katalog -> Instanz-Snapshot (für Board-Katalog / lastStickyCount)
    dtInstancesById.forEach((inst) => {
      const liveInst = dtLiveCatalog.instances[inst.instanceId];
      if (liveInst && liveInst.meta) {
        inst.lastStickyCount = liveInst.meta.stickyCount || 0;
      }
    });


    // NEU: live-Katalog → Instanz-Snapshot (für Board-Katalog)
    dtInstancesById.forEach((inst) => {
      const liveInst = dtLiveCatalog.instances[inst.instanceId];
      if (liveInst && liveInst.meta) {
        inst.lastStickyCount = liveInst.meta.stickyCount || 0;
      }
    });
  }


  // LiveInstance -> "classification"-Objekt (kompatibel zu dtBuildPromptPayloadFromClassification)
  function dtBuildClassificationFromLiveInstance(instance, liveInst) {
    const items = [];
    const headerStickies = [];

    // Header
    for (const s of liveInst.regions.header.stickies) {
      items.push({
        stickyId: s.id,
        text: s.text,
        role: "header",
        regionId: null,
        regionTitle: "Header",
        color: s.color,
        tags: s.tags.map((title) => ({ id: null, title })),
        clusterName: s.clusterName,
        connectionsOut: [],
        connectionsIn: []
      });
      headerStickies.push({
        stickyId: s.id,
        text: s.text,
        px: s.px,
        py: s.py,
        color: s.color,
        tagIds: [],
        tags: s.tags.map((title) => ({ id: null, title }))
      });
    }

    function addBodyRegion(regionId, regionTitle, list) {
      for (const s of list) {
        items.push({
          stickyId: s.id,
          text: s.text,
          role: "body",
          regionId,
          regionTitle,
          color: s.color,
          tags: s.tags.map((title) => ({ id: null, title })),
          clusterName: s.clusterName,
          connectionsOut: [],
          connectionsIn: []
        });
      }
    }

    addBodyRegion("left",   "Box 1 (links)",  liveInst.regions.body.left.stickies);
    addBodyRegion("middle", "Box 2 (Mitte)",  liveInst.regions.body.middle.stickies);
    addBodyRegion("right",  "Box 3 (rechts)", liveInst.regions.body.right.stickies);
    addBodyRegion(null,     null,             liveInst.regions.body.none.stickies);

    // Footer (falls du dort Stickies hast, analog)
    for (const s of liveInst.regions.footer.stickies) {
      items.push({
        stickyId: s.id,
        text: s.text,
        role: "footer",
        regionId: null,
        regionTitle: "Footer",
        color: s.color,
        tags: s.tags.map((title) => ({ id: null, title })),
        clusterName: s.clusterName,
        connectionsOut: [],
        connectionsIn: []
      });
    }

    // Verbindungen in items eintragen
    const idToItem = {};
    for (const it of items) {
      if (it && it.stickyId) {
        idToItem[it.stickyId] = it;
      }
    }

    const connections = [];
    for (const c of liveInst.connections || []) {
      const fromItem = idToItem[c.fromStickyId];
      const toItem   = idToItem[c.toStickyId];
      if (!fromItem || !toItem) continue;

      const conn = {
        connectorId: c.connectorId,
        fromStickyId: c.fromStickyId,
        toStickyId: c.toStickyId
      };
      connections.push(conn);

      fromItem.connectionsOut.push({
        connectorId: c.connectorId,
        toStickyId: c.toStickyId
      });
      toItem.connectionsIn.push({
        connectorId: c.connectorId,
        fromStickyId: c.fromStickyId
      });
    }

    const counts = {
      total: items.length,
      byRegion: {}
    };
    for (const it of items) {
      if (it.role === "body" && it.regionId) {
        counts.byRegion[it.regionId] = (counts.byRegion[it.regionId] || 0) + 1;
      }
    }

    const headerSummaryRaw = headerStickies
      .map((h) => h.text)
      .filter(Boolean)
      .join(" | ");
    const headerSummary = headerSummaryRaw
      ? (headerSummaryRaw.length > 200 ? headerSummaryRaw.slice(0, 197) + "..." : headerSummaryRaw)
      : null;

    return {
      template: {
        id: instance.canvasTypeId,
        name: instance.title || "Datentreiber 3-Boxes",
        imageId: instance.imageId,
        headerSummary: headerSummary
      },
      header: {
        stickies: headerStickies
      },
      counts,
      items,
      connections
    };
  }

  // --------------------------------------------------------------------
  // 2b) Klassifikation (Debug-Button) – nutzt nur noch dtLiveCatalog
  // --------------------------------------------------------------------
  async function dtClassifyStickies(options) {
    const silent = options && options.silent;
    if (!silent) {
      log("Button: Stickies klassifizieren (Debug-Modus).");
    }

    await dtEnsureMiroReady();
    const ctx = await dtGetBoardBaseContext();
    await dtRebuildLiveCatalog(ctx);

    const results = [];
    dtInstancesById.forEach((inst) => {
      const liveInst = dtLiveCatalog.instances[inst.instanceId];
      if (!liveInst) return;
      const classification = dtBuildClassificationFromLiveInstance(inst, liveInst);
      results.push(classification);
    });

    if (!results.length) {
      if (!silent) {
        log("Keine Canvas-Instanzen mit Stickies gefunden.");
      }
      lastClassification = null;
      return null;
    }

    lastClassification =
      results.length === 1 ? results[0] : { templates: results };

    if (!silent) {
      if (results.length === 1) {
        log("Klassifikation fertig (1 Instanz):");
        log(lastClassification);
      } else {
        log("Klassifikation fertig für " + results.length + " Instanzen:");
        log(lastClassification);
      }
    }

    return lastClassification;
  }

  // --------------------------------------------------------------------
  // 2c) Reduziertes JSON für das Sprachmodell (optional mit Aliassen)
  // --------------------------------------------------------------------
  function dtBuildPromptPayloadFromClassification(classification, options) {
    if (!classification) {
      return null;
    }

    options = options || {};
    const useAliases = !!options.useAliases;

    if (useAliases) {
      if (!dtLastAliasMap) {
        dtLastAliasMap = {
          sticky: {},
          stickyReverse: {}
        };
      }
    }

    const perTemplate = Array.isArray(classification.templates) && classification.templates.length
      ? classification.templates
      : [classification];

    function getOrCreateStickyAlias(stickyId) {
      if (!useAliases || !stickyId) {
        return null;
      }
      const map = dtLastAliasMap;
      const reverse = map.stickyReverse;
      let alias = reverse[stickyId];
      if (alias) {
        return alias;
      }
      const index = dtNextStickyAliasIndex++;
      const padded = String(index).padStart(4, "0");
      alias = "S" + padded;
      map.sticky[alias] = stickyId;
      reverse[stickyId] = alias;
      return alias;
    }

    function transformOne(one) {
      const idToItem = {};
      if (Array.isArray(one.items)) {
        for (const item of one.items) {
          if (item && item.stickyId) {
            idToItem[item.stickyId] = item;
          }
        }
      }

      function buildConnectionsOut(item) {
        const result = [];
        if (!item || !Array.isArray(item.connectionsOut)) {
          return result;
        }
        for (const co of item.connectionsOut) {
          const target = co && idToItem[co.toStickyId];
          const toText = target ? target.text : null;
          const toArea = target
            ? (target.regionTitle || (target.role === "header" ? "Header" : null))
            : null;
          result.push({
            connectorId: co.connectorId,
            toText: toText,
            toArea: toArea
          });
        }
        return result;
      }

      function buildConnectionsIn(item) {
        const result = [];
        if (!item || !Array.isArray(item.connectionsIn)) {
          return result;
        }
        for (const ci of item.connectionsIn) {
          const source = ci && idToItem[ci.fromStickyId];
          const fromText = source ? source.text : null;
          const fromArea = source
            ? (source.regionTitle || (source.role === "header" ? "Header" : null))
            : null;
          result.push({
            connectorId: ci.connectorId,
            fromText: fromText,
            fromArea: fromArea
          });
        }
        return result;
      }

      const headerStickiesRaw =
        (one.header && Array.isArray(one.header.stickies) && one.header.stickies) || [];

      const header = {
        summary: one.template && one.template.headerSummary,
        stickies: headerStickiesRaw.map(function (h) {
          const item = h.stickyId ? idToItem[h.stickyId] : null;
          const tagObjs = item && Array.isArray(item.tags)
            ? item.tags
            : (Array.isArray(h.tags) ? h.tags : []);
          const tags = tagObjs
            .map(function (t) { return t && t.title; })
            .filter(function (title) { return !!title; });

          const alias = item && item.stickyId ? getOrCreateStickyAlias(item.stickyId) : null;

          return {
            id: alias,
            text: h.text,
            color: (item && item.color) || h.color || null,
            tags: tags,
            clusterName: item && item.clusterName ? item.clusterName : null,
            connectionsOut: buildConnectionsOut(item),
            connectionsIn: buildConnectionsIn(item)
          };
        })
      };

      const areasByName = {};

      if (Array.isArray(one.items)) {
        for (const item of one.items) {
          if (!item) {
            continue;
          }
          if (item.role === "header") {
            continue;
          }

          const areaName = item.regionTitle || "Ohne Area";
          if (!areasByName[areaName]) {
            areasByName[areaName] = {
              name: areaName,
              stickies: []
            };
          }

          const tags = Array.isArray(item.tags)
            ? item.tags
                .map(function (t) { return t && t.title; })
                .filter(function (title) { return !!title; })
            : [];

          const alias = getOrCreateStickyAlias(item.stickyId);

          const stickObj = {
            id: alias,
            text: item.text,
            color: item.color || null,
            tags: tags,
            clusterName: item.clusterName || null,
            connectionsOut: buildConnectionsOut(item),
            connectionsIn: buildConnectionsIn(item)
          };

          areasByName[areaName].stickies.push(stickObj);
        }
      }

      const connectionsSummary = Array.isArray(one.connections)
        ? one.connections.map(function (c) {
            const fromItem = c.fromStickyId ? idToItem[c.fromStickyId] : null;
            const toItem = c.toStickyId ? idToItem[c.toStickyId] : null;

            const fromArea = fromItem
              ? (fromItem.regionTitle || (fromItem.role === "header" ? "Header" : null))
              : null;
            const toArea = toItem
              ? (toItem.regionTitle || (toItem.role === "header" ? "Header" : null))
              : null;

            return {
              connectorId: c.connectorId,
              fromText: fromItem ? fromItem.text : null,
              fromArea: fromArea,
              toText: toItem ? toItem.text : null,
              toArea: toArea
            };
          })
        : [];

      return {
        template: {
          name: one.template && one.template.name,
          headerSummary: one.template && one.template.headerSummary
        },
        header: header,
        areas: Object.keys(areasByName).map(function (key) {
          return areasByName[key];
        }),
        connections: connectionsSummary
      };
    }

    const templatesPayload = perTemplate.map(transformOne);

    return {
      templates: templatesPayload
    };
  }

  // --------------------------------------------------------------------
  // 3) Klassischer OpenAI-Call (Side-Panel) – nutzt dtClassifyStickies()
  // --------------------------------------------------------------------
  async function dtCallOpenAI() {
    await dtEnsureMiroReady();

    const apiKey  = document.getElementById("api-key").value.trim();
    const model   = document.getElementById("model").value;
    const userText = document.getElementById("user-text").value.trim();

    if (!apiKey) {
      log("Bitte OpenAI API Key eingeben.");
      return;
    }
    if (!userText) {
      log("Bitte eine Frage / Aufgabe im Textfeld eingeben.");
      return;
    }

    const classification = await dtClassifyStickies({ silent: true });

    const promptPayload = classification
      ? dtBuildPromptPayloadFromClassification(classification, { useAliases: false })
      : null;

    const classificationPart = promptPayload
      ? "\n\nAktuelle Sticky-Notiz-Klassifikation (reduziertes JSON für das Sprachmodell):\n" +
        JSON.stringify(promptPayload, null, 2)
      : "\n\nHinweis: Es liegt noch keine Klassifikation vor (kein Template gesetzt " +
        "oder keine Stickies innerhalb der Templates).";

    const fullUserText = userText + classificationPart;

    const body = {
      model,
      input: [
        {
          role: "system",
          content: [
            {
              type: "input_text",
              text:
                "Du bist ein Assistent, der Miro-Boards analysiert. " +
                "Du bekommst Sticky-Notes als JSON und eine Nutzerfrage " +
                "und sollst exakte Antworten liefern. " +
                "Antworte standardmäßig auf Deutsch."
            }
          ]
        },
        {
          role: "user",
          content: [
            {
              type: "input_text",
              text: fullUserText
            }
          ]
        }
      ],
      max_output_tokens: 10000
    };

    try {
      log("Sende Anfrage an OpenAI (klassischer Call) ...");
      const res = await fetch("https://api.openai.com/v1/responses", {
        method: "POST",
        headers: {
          "Authorization": "Bearer " + apiKey,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });

      const text = await res.text();
      if (!res.ok) {
        log("Fehler bei OpenAI-Anfrage: " + res.status + " " + text);
        return;
      }

      const data = JSON.parse(text);
      const firstMessage = data.output && data.output[0];
      const contentArr = firstMessage && firstMessage.content;
      const textPart = contentArr && contentArr.find((c) => c.type === "output_text");
      const answer = textPart ? textPart.text : "(keine Antwort gefunden)";

      log("Antwort von OpenAI (klassischer Call):");
      log(answer);
    } catch (e) {
      log("Exception beim Aufruf der OpenAI API: " + e.message);
    }
  }

  // --------------------------------------------------------------------
  // 4) Change-Tracker
  // --------------------------------------------------------------------
  function dtComputeInstanceDiff(prevClassification, newClassification) {
    const diff = {
      created: [],
      deleted: [],
      updated: []
    };

    function itemAreaName(it) {
      if (!it) return null;
      if (it.regionTitle) return it.regionTitle;
      if (it.role === "header") return "Header";
      if (it.role === "footer") return "Footer";
      return null;
    }

    if (!newClassification || !Array.isArray(newClassification.items)) {
      if (prevClassification && Array.isArray(prevClassification.items)) {
        prevClassification.items.forEach(function (oldItem) {
          if (oldItem && oldItem.stickyId) {
            dtClusterAssignments.delete(oldItem.stickyId);
          }
          diff.deleted.push({
            stickyId: oldItem.stickyId,
            text: oldItem.text || "",
            areaName: itemAreaName(oldItem),
            color: oldItem.color || null,
            clusterName: oldItem.clusterName || null
          });
        });
      }
      return diff;
    }

    const prevItemsById = {};
    if (prevClassification && Array.isArray(prevClassification.items)) {
      prevClassification.items.forEach(function (item) {
        if (item && item.stickyId) {
          prevItemsById[item.stickyId] = item;
        }
      });
    }

    const newItemsById = {};
    newClassification.items.forEach(function (item) {
      if (item && item.stickyId) {
        newItemsById[item.stickyId] = item;
      }
    });

    const prevIds = Object.keys(prevItemsById);
    const newIds = Object.keys(newItemsById);

    const prevIdSet = {};
    prevIds.forEach(function (id) { prevIdSet[id] = true; });

    const newIdSet = {};
    newIds.forEach(function (id) { newIdSet[id] = true; });

    newIds.forEach(function (id) {
      if (!prevIdSet[id]) {
        const it = newItemsById[id];
        diff.created.push({
          stickyId: it.stickyId,
          text: it.text || "",
          areaName: itemAreaName(it),
          color: it.color || null,
          clusterName: it.clusterName || null
        });
      }
    });

    prevIds.forEach(function (id) {
      if (!newIdSet[id]) {
        const it = prevItemsById[id];
        if (it && it.stickyId) {
          dtClusterAssignments.delete(it.stickyId);
        }
        diff.deleted.push({
          stickyId: it.stickyId,
          text: it.text || "",
          areaName: itemAreaName(it),
          color: it.color || null,
          clusterName: it.clusterName || null
        });
      }
    });

    function normalizeTags(tags) {
      if (!Array.isArray(tags)) {
        return "";
      }
      const titles = tags
        .map(function (t) { return t && t.title; })
        .filter(function (t) { return !!t; })
        .sort();
      return titles.join("|");
    }

    newIds.forEach(function (id) {
      const oldItem = prevItemsById[id];
      const newItem = newItemsById[id];
      if (!oldItem || !newItem) {
        return;
      }

      const oldSummary = {
        text: oldItem.text || "",
        areaName: itemAreaName(oldItem),
        color: oldItem.color || null,
        clusterName: oldItem.clusterName || null,
        tags: normalizeTags(oldItem.tags)
      };

      const newSummary = {
        text: newItem.text || "",
        areaName: itemAreaName(newItem),
        color: newItem.color || null,
        clusterName: newItem.clusterName || null,
        tags: normalizeTags(newItem.tags)
      };

      const areaChanged = oldSummary.areaName !== newSummary.areaName;
      if (areaChanged && oldSummary.clusterName) {
        dtClusterAssignments.delete(newItem.stickyId);
        newSummary.clusterName = null;
        if (newItem) {
          newItem.clusterName = null;
        }
      }

      const isSame =
        oldSummary.text === newSummary.text &&
        oldSummary.areaName === newSummary.areaName &&
        oldSummary.color === newSummary.color &&
        oldSummary.clusterName === newSummary.clusterName &&
        oldSummary.tags === newSummary.tags;

      if (!isSame) {
        diff.updated.push({
          stickyId: newItem.stickyId,
          before: oldSummary,
          after: newSummary
        });
      }
    });

    return diff;
  }

  // --------------------------------------------------------------------
  // 5) Agent-Hilfsfunktionen (Instanzzustand) – jetzt über dtLiveCatalog
  // --------------------------------------------------------------------
  async function dtGetInstanceStateForAgent(instance, options) {
    await dtEnsureMiroReady();

    options = options || {};
    let ctx = options.ctx;
    const liveCatalogReady = !!options.liveCatalogReady;

    if (!liveCatalogReady) {
      ctx = ctx || await dtGetBoardBaseContext();
      await dtRebuildLiveCatalog(ctx);
    }

    const liveInst = dtLiveCatalog.instances[instance.instanceId];
    if (!liveInst) {
      log("dtGetInstanceStateForAgent: Keine Live-Daten für Instanz " + instance.instanceId);
      return null;
    }

    const classification = dtBuildClassificationFromLiveInstance(instance, liveInst);

    const baselineClassification = instance.baselineClassification || null;
    let diff = null;
    if (baselineClassification) {
      diff = dtComputeInstanceDiff(baselineClassification, classification);
    } else {
      diff = dtComputeInstanceDiff(null, classification);
    }

    const payload = dtBuildPromptPayloadFromClassification(classification, {
      useAliases: false
    });

    const stateJson = JSON.stringify(payload, null, 2);

    instance.lastClassification = classification;
    instance.lastStateJson = stateJson;
    instance.lastStickyCount =
      liveInst.meta && typeof liveInst.meta.stickyCount === "number"
        ? liveInst.meta.stickyCount
        : (classification && classification.counts
            ? classification.counts.total || 0
            : Array.isArray(classification.items)
              ? classification.items.length
              : 0);

    instance.lastDiff = diff;
    instance.liveCatalog = liveInst;

    return {
      classification: classification,
      promptPayload: payload,
      stateJson: stateJson,
      diff: diff
    };
  }

  function dtNormalizedToBoardCoords(templateGeometry, px, py) {
    const { x, y, width, height } = templateGeometry;
    const left = x - width / 2;
    const top = y - height / 2;
    const bx = left + px * width;
    const by = top + py * height;
    return { x: bx, y: by };
  }

  function dtAreaCenterNormalizedFromDef(canvasTypeId, regionId) {
    const def = dtGetCanvasDef(canvasTypeId);
    if (!def || !Array.isArray(def.regionPolygons)) {
      return null;
    }
    const r = def.regionPolygons.find(
      (rp) => rp.id === regionId || rp.title === regionId
    );
    if (!r || !Array.isArray(r.polygonNorm) || !r.polygonNorm.length) {
      return null;
    }
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (const pt of r.polygonNorm) {
      const x = pt[0];
      const y = pt[1];
      if (x < minX) minX = x;
      if (x > maxX) maxX = x;
      if (y < minY) minY = y;
      if (y > maxY) maxY = y;
    }
    return {
      px: (minX + maxX) / 2,
      py: (minY + maxY) / 2
    };
  }

  function dtAreaCenterNormalized(regionId, canvasTypeId) {
    if (regionId && canvasTypeId) {
      const centerFromDef = dtAreaCenterNormalizedFromDef(canvasTypeId, regionId);
      if (centerFromDef) {
        return centerFromDef;
      }
    }

    const yMin = 0.20;
    const yMax = 0.95;
    const py = (yMin + yMax) / 2;

    if (regionId === "left") {
      return { px: 1 / 6, py };
    } else if (regionId === "middle") {
      return { px: 0.5, py };
    } else if (regionId === "right") {
      return { px: 5 / 6, py };
    }
    return { px: 0.5, py: 0.5 };
  }

  function dtResolveStickyId(stickyIdOrAlias) {
    if (!stickyIdOrAlias) return null;
    if (dtLastAliasMap && dtLastAliasMap.sticky && dtLastAliasMap.sticky[stickyIdOrAlias]) {
      return dtLastAliasMap.sticky[stickyIdOrAlias];
    }
    return stickyIdOrAlias;
  }

  async function dtActionMoveSticky(instance, templateGeometry, action) {
    const rawId = action.stickyId;
    const stickyId = dtResolveStickyId(rawId);
    if (!stickyId) return;

    const canvasTypeId = instance ? instance.canvasTypeId : TEMPLATE_ID;

    let targetPx = action.targetPx;
    let targetPy = action.targetPy;

    if (typeof targetPx !== "number" || typeof targetPy !== "number") {
      const region = dtAreaNameToRegion(action.targetArea);
      const center = dtAreaCenterNormalized(region ? region.id : null, canvasTypeId);
      targetPx = center.px;
      targetPy = center.py;
    }

    try {
      let arr = await miro.board.get({ id: stickyId });
      const sticky = Array.isArray(arr) ? arr[0] : arr;
      if (!sticky) {
        log("move_sticky: Sticky mit ID " + stickyId + " nicht gefunden.");
        return;
      }

      const coords = dtNormalizedToBoardCoords(templateGeometry, targetPx, targetPy);
      sticky.x = coords.x;
      sticky.y = coords.y;
      await sticky.sync();
    } catch (e) {
      log("Fehler bei move_sticky (" + stickyId + "): " + e.message);
    }
  }

  // create_sticky: platziert ein neues Sticky exakt im Schwerpunkt der Ziel-Region
  // der gegebenen Instanz. Keine Frame-Zuordnung, reine Geometrie-Logik.
  async function dtActionCreateSticky(instance, templateGeometry, action) {
    const areaName = action.area;
    const text = action.text || "";
    const region = dtAreaNameToRegion(areaName);
    const canvasTypeId = instance ? instance.canvasTypeId : TEMPLATE_ID;
  
    // Wenn aus irgendeinem Grund keine Geometrie bekannt ist, brechen wir ab.
    if (!templateGeometry) {
      log(
        "create_sticky: Keine Template-Geometrie für Instanz " +
        (instance ? instance.instanceId : "(unbekannt)") +
        " – Sticky wird nicht erstellt."
      );
      return;
    }
  
    // 1) Schwerpunkt der Region im normalisierten Canvas holen (0..1)
    const centerNorm = dtAreaCenterNormalized(region ? region.id : null, canvasTypeId);
  
    // 2) Auf Board-Koordinaten der konkreten Instanz abbilden
    const coords = dtNormalizedToBoardCoords(
      templateGeometry,
      centerNorm.px,
      centerNorm.py
    );
  
    const createPayload = {
      content: text || "(leer)",
      x: coords.x,
      y: coords.y
      // Wenn du die Farbe vom Agenten übernehmen willst, kannst du hier
      // später noch style/fillColor ergänzen.
    };
  
    try {
      const sticky = await miro.board.createStickyNote(createPayload);
  
      if (!sticky || !sticky.id) {
        log(
          "create_sticky: createStickyNote hat kein gültiges Sticky zurückgegeben. Payload:\n" +
          JSON.stringify(createPayload, null, 2)
        );
        return;
      }
  
      // Sicherstellen, dass das Sticky nicht unter dem Template-PNG liegt
      try {
        if (typeof sticky.bringToFront === "function") {
          await sticky.bringToFront();
        }
      } catch (e2) {
        log(
          "create_sticky: bringToFront nicht möglich für Sticky " +
          sticky.id +
          ": " +
          e2.message
        );
      }
  
      log(
        "create_sticky: Neues Sticky erstellt (" +
        sticky.id +
        ") für Instanz " +
        (instance ? instance.instanceId : "(unbekannt)") +
        " in Area '" +
        areaName +
        "' bei x=" +
        coords.x +
        ", y=" +
        coords.y
      );
  
      // WICHTIG:
      // Kein frame.add(sticky) mehr, keine Parent-Beziehung zum Frame.
      // Die Zugehörigkeit zur Instanz erfolgt ausschließlich über die
      // geometrische Lage relativ zum Template-Bild.
    } catch (e) {
      log(
        "Fehler bei create_sticky (Instanz " +
        (instance ? instance.instanceId : "(unbekannt)") +
        ", Area '" +
        areaName +
        "'):\n" +
        e.message
      );
    }
  }


  async function dtActionDeleteSticky(action) {
    const rawId = action.stickyId;
    const stickyId = dtResolveStickyId(rawId);
    if (!stickyId) return;

    try {
      const arr = await miro.board.get({ id: stickyId });
      const sticky = Array.isArray(arr) ? arr[0] : arr;
      if (!sticky) {
        log("delete_sticky: Sticky mit ID " + stickyId + " nicht gefunden.");
        return;
      }
      await miro.board.remove(sticky);
    } catch (e) {
      log("Fehler bei delete_sticky (" + stickyId + "): " + e.message);
    }
  }

  async function dtApplyCanvasActions(instanceId, actions) {
    if (!Array.isArray(actions) || !actions.length) {
      log("Keine Actions vom Agenten erhalten (actions-Array ist leer).");
      return;
    }

    const instance = dtInstancesById.get(instanceId);
    if (!instance) {
      log("dtApplyCanvasActions: Unbekannte Instanz-ID " + instanceId);
      return;
    }

    const geom = await dtComputeTemplateGeometry(instance);
    if (!geom) {
      log(
        "dtApplyCanvasActions: Keine Geometrie für Instanz " +
        instanceId +
        " verfügbar."
      );
      return;
    }

    log(
      "Wende " +
      actions.length +
      " Action(s) auf Instanz " +
      instanceId +
      " an (aktuelle Canvas-Geometrie wird verwendet)."
    );

    for (const action of actions) {
      if (!action || !action.type) {
        continue;
      }

      const type = action.type;

      if (type === "move_sticky") {
        await dtActionMoveSticky(instance, geom, action);
      } else if (type === "create_sticky") {
        await dtActionCreateSticky(instance, geom, action);
      } else if (type === "delete_sticky") {
        await dtActionDeleteSticky(action);
      } else {
        log("Unbekannter Action-Typ vom Agenten: " + type);
      }
    }
  }

  // Diff auf Alias-IDs ummappen
  function dtAliasDiffForActiveInstance(diff) {
    if (!diff) return null;
    if (!dtLastAliasMap || !dtLastAliasMap.stickyReverse) {
      return diff;
    }
    const reverse = dtLastAliasMap.stickyReverse;

    function aliasId(id) {
      if (!id) return id;
      return reverse[id] || id;
    }

    const out = {
      created: [],
      deleted: [],
      updated: []
    };

    if (Array.isArray(diff.created)) {
      diff.created.forEach(function (entry) {
        const copy = Object.assign({}, entry);
        copy.stickyId = aliasId(entry.stickyId);
        out.created.push(copy);
      });
    }
    if (Array.isArray(diff.deleted)) {
      diff.deleted.forEach(function (entry) {
        const copy = Object.assign({}, entry);
        copy.stickyId = aliasId(entry.stickyId);
        out.deleted.push(copy);
      });
    }
    if (Array.isArray(diff.updated)) {
      diff.updated.forEach(function (entry) {
        const copy = {
          stickyId: aliasId(entry.stickyId),
          before: entry.before,
          after: entry.after
        };
        out.updated.push(copy);
      });
    }

    return out;
  }

  async function dtComputeTemplateGeometry(instance) {
    if (!instance) {
      return null;
    }
  
    await dtEnsureMiroReady();
  
    // 1. Wahrheit: Geometrie des Template-PNGs
    if (instance.imageId) {
      try {
        const imgArr = await miro.board.get({ id: instance.imageId });
        const img = Array.isArray(imgArr) ? imgArr[0] : imgArr;
  
        if (img && typeof img.x === "number" && typeof img.y === "number") {
          const geom = {
            x: img.x,
            y: img.y,
            width: img.width,
            height: img.height
          };
          instance.lastGeometry = geom;
          return geom;
        }
      } catch (e) {
        log("Fehler beim Laden der Template-Geometrie aus dem Bild: " + e.message);
      }
    }
  
    // 2. Fallback: zuletzt bekannte Geometrie (vom PNG)
    return instance.lastGeometry || null;
  }



  // --------------------------------------------------------------------
  // 6) Globaler Agenten-Modus A – nutzt dtLiveCatalog
  // --------------------------------------------------------------------
  async function dtRunGlobalAgent(triggerInstanceId, userText) {
    await dtEnsureMiroReady();
    await dtScanTemplateInstances();

    const apiKey  = document.getElementById("api-key").value.trim();
    const model   = document.getElementById("model").value;
    const rawUserText = userText || "";
    const finalUserText = rawUserText.trim()
      ? rawUserText.trim()
      : "Bitte gib mir einen globalen Überblick über alle relevanten Canvas-Instanzen und schlage sinnvolle nächste Schritte vor.";

    if (!apiKey) {
      log("Bitte OpenAI API Key eingeben (für den globalen Agenten-Run).");
      return;
    }

    log(
      "Starte globalen Agenten-Run (Modus A), ausgelöst von Instanz " +
      (triggerInstanceId || "(keine)") +
      "."
    );

    const ctx = await dtGetBoardBaseContext();
    await dtRebuildLiveCatalog(ctx);

    const stateById = {};

    const allInstances = [];
    dtInstancesById.forEach(function (inst) {
      allInstances.push(inst);
    });

    for (const inst of allInstances) {
      const st = await dtGetInstanceStateForAgent(inst, {
        ctx: ctx,
        liveCatalogReady: true
      });
      if (st) {
        stateById[inst.instanceId] = st;
      }
    }

    const boardCatalog = dtBuildBoardCatalogSummary({
      mode: "global",
      hasGlobalBaseline: dtHasGlobalBaseline
    });

    const activeInstanceIds = boardCatalog.instances
      .filter((entry) => entry.isActive)
      .map((entry) => entry.instanceId);

    if (!activeInstanceIds.length) {
      log("Globaler Agent: Es wurden keine aktiven Instanzen mit inhaltlichen Änderungen seit dem letzten Agenten-Call gefunden.");
    }

    const activeCanvasStates = {};
    const activeInstanceChangesSinceLastAgent = {};

    for (const id of activeInstanceIds) {
      const st = stateById[id];
      if (!st || !st.classification) {
        continue;
      }
      const payload = dtBuildPromptPayloadFromClassification(
        st.classification,
        { useAliases: true }
      );
      if (payload) {
        activeCanvasStates[id] = payload;
      }
    }

    for (const id of activeInstanceIds) {
      const st = stateById[id];
      if (!st || !st.diff) {
        activeInstanceChangesSinceLastAgent[id] = null;
        continue;
      }
      if (!dtHasGlobalBaseline) {
        activeInstanceChangesSinceLastAgent[id] = null;
      } else {
        const aliasDiff = dtAliasDiffForActiveInstance(st.diff);
        activeInstanceChangesSinceLastAgent[id] = aliasDiff || null;
      }
    }

    const userPayload = {
      userQuestion: finalUserText,
      triggerInstanceId: triggerInstanceId || null,
      hasBaseline: dtHasGlobalBaseline,
      boardCatalog: boardCatalog,
      activeInstanceIds: activeInstanceIds,
      activeCanvasStates: activeCanvasStates,
      activeInstanceChangesSinceLastAgent: activeInstanceChangesSinceLastAgent,
      hint: "boardCatalog enthält eine Übersicht über alle Instanzen. activeCanvasStates enthält Detaildaten nur für aktive Instanzen."
    };

    const body = {
      model,
      input: [
        {
          role: "system",
          content: [
            {
              type: "input_text",
              text: DT_GLOBAL_SYSTEM_PROMPT
            }
          ]
        },
        {
          role: "user",
          content: [
            {
              type: "input_text",
              text: JSON.stringify(userPayload, null, 2)
            }
          ]
        }
      ],
      max_output_tokens: 4000
    };

    try {
      log("Sende globalen Agent-Request an OpenAI (Modus A) ...");
      const res = await fetch("https://api.openai.com/v1/responses", {
        method: "POST",
        headers: {
          "Authorization": "Bearer " + apiKey,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });

      const text = await res.text();
      if (!res.ok) {
        log("Fehler bei OpenAI-Agent-Anfrage (global): " + res.status + " " + text);
        return;
      }

      const data = JSON.parse(text);
      const firstMessage = data.output && data.output[0];
      const contentArr = firstMessage && firstMessage.content;
      const textPart = contentArr && contentArr.find((c) => c.type === "output_text");
      const answer = textPart ? textPart.text : null;

      if (!answer) {
        log("Globaler Agent: Keine output_text-Antwort gefunden.");
        return;
      }

      let agentObj = null;
      try {
        agentObj = JSON.parse(answer);
      } catch (e) {
        log("Globaler Agent: Antwort ist kein valides JSON. Rohantwort:");
        log(answer);
        return;
      }

      log("Globale Agent-Analyse (analysis):");
      log(agentObj.analysis || "(keine analysis)");

      if (Array.isArray(agentObj.actions) && agentObj.actions.length) {
        log("Globale Agent-Actions (werden aktuell nur geloggt, nicht automatisch angewendet):");
        log(agentObj.actions);
      } else {
        log("Globaler Agent lieferte keine Actions (actions-Array ist leer).");
      }

      try {
        const nowIso = new Date().toISOString();
        dtInstancesById.forEach(function (inst) {
          const st = stateById[inst.instanceId];
          if (st && st.classification) {
            inst.baselineClassification = st.classification;
            inst.baselineStateJson = st.stateJson;
            inst.lastDiff = null;
            inst.lastAgentRunAt = nowIso;
            inst.lastChangedAt = nowIso;
          }
        });
        dtHasGlobalBaseline = true;
      } catch (e2) {
        log("Fehler beim Aktualisieren der Baseline nach globalem Agent-Run: " + e2.message);
      }
    } catch (e) {
      log("Exception beim globalen Agent-Run: " + e.message);
    }
  }

  // --------------------------------------------------------------------
  // 7) Instanzspezifischer Agenten-Modus B – nutzt dtLiveCatalog
  // --------------------------------------------------------------------
  async function dtRunAgentForInstance(instanceId, options) {
    await dtEnsureMiroReady();
    await dtScanTemplateInstances();

    const apiKey  = document.getElementById("api-key").value.trim();
    const model   = document.getElementById("model").value;
    const userText = (options && options.userText) || dtGetCurrentUserQuestion();

    if (!apiKey) {
      log("Bitte OpenAI API Key eingeben (für den Agenten-Run).");
      return;
    }

    const instance = dtInstancesById.get(instanceId);
    if (!instance) {
      log("Unbekannte Canvas-Instanz: " + instanceId);
      return;
    }

    const promptCfg = DT_PROMPT_CATALOG[instance.canvasTypeId] || DT_PROMPT_CATALOG[TEMPLATE_ID];
    const systemPrompt = promptCfg.system;

    log("Starte Agent (Modus B, instanzspezifisch) für Instanz " + instanceId + " ...");

    const ctx = await dtGetBoardBaseContext();
    await dtRebuildLiveCatalog(ctx);

    const stateById = {};

    const instForState = dtInstancesById.get(instanceId);
    if (!instForState) {
      log("Konnte Instanz " + instanceId + " nicht im Instanz-Register finden.");
      return;
    }

    const st = await dtGetInstanceStateForAgent(instForState, {
      ctx: ctx,
      liveCatalogReady: true
    });
    if (st) {
      stateById[instanceId] = st;
    }

    const mainState = stateById[instanceId];
    if (!mainState || !mainState.classification) {
      log("Konnte Instanzzustand für den Agenten nicht ermitteln.");
      return;
    }

    const activeCanvasStates = {};
    {
      const stLocal = stateById[instanceId];
      if (stLocal && stLocal.classification) {
        const payload = dtBuildPromptPayloadFromClassification(stLocal.classification, { useAliases: true });
        if (payload) {
          activeCanvasStates[instanceId] = payload;
        }
      }
    }

    const activeCanvasState = activeCanvasStates[instanceId];
    if (!activeCanvasState) {
      log("Konnte aktiven Canvas-Status mit Alias-IDs nicht aufbereiten.");
      return;
    }

    const boardCatalog = dtBuildBoardCatalogSummary({
      mode: "instance",
      activeInstanceId: instanceId
    });

    let aliasDiff = null;
    if (instance.baselineClassification) {
      const rawDiff = mainState.diff;
      const mapped = dtAliasDiffForActiveInstance(rawDiff);
      if (
        mapped &&
        Array.isArray(mapped.created) &&
        Array.isArray(mapped.deleted) &&
        Array.isArray(mapped.updated) &&
        (mapped.created.length || mapped.deleted.length || mapped.updated.length)
      ) {
        aliasDiff = mapped;
      } else {
        aliasDiff = null;
      }
    }

    const detailInstanceIds = [instanceId];

    const userPayload = {
      userQuestion: userText,
      activeInstanceId: instanceId,
      selectedInstanceIds: detailInstanceIds,
      boardCatalog: boardCatalog,
      activeCanvasState: activeCanvasState,
      activeCanvasStates: activeCanvasStates,
      activeInstanceChangesSinceLastAgent: aliasDiff,
      hint: "boardCatalog = Kurzüberblick über alle Instanzen (inkl. Changes seit letztem Agent-Run, nur als Summary), activeCanvasStates = detaillierte Stickies/Areas/Verbindungen nur für diese Instanz."
    };

    const body = {
      model,
      input: [
        {
          role: "system",
          content: [
            {
              type: "input_text",
              text: systemPrompt
            }
          ]
        },
        {
          role: "user",
          content: [
            {
              type: "input_text",
              text: JSON.stringify(userPayload, null, 2)
            }
          ]
        }
      ],
      max_output_tokens: 4000
    };

    try {
      log("Sende Agent-Request an OpenAI (Instanz " + instanceId + ", Modus B) ...");
      const res = await fetch("https://api.openai.com/v1/responses", {
        method: "POST",
        headers: {
          "Authorization": "Bearer " + apiKey,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });

      const text = await res.text();
      if (!res.ok) {
        log("Fehler bei OpenAI-Agent-Anfrage: " + res.status + " " + text);
        return;
      }

      const data = JSON.parse(text);
      const firstMessage = data.output && data.output[0];
      const contentArr = firstMessage && firstMessage.content;
      const textPart = contentArr && contentArr.find((c) => c.type === "output_text");
      const answer = textPart ? textPart.text : null;

      if (!answer) {
        log("Agent: Keine output_text-Antwort gefunden.");
        return;
      }

      let agentObj = null;
      try {
        agentObj = JSON.parse(answer);
      } catch (e) {
        log("Agent-Antwort ist kein valides JSON. Rohantwort:");
        log(answer);
        return;
      }

      log("Agent-Analyse (analysis):");
      log(agentObj.analysis || "(keine analysis)");

      if (Array.isArray(agentObj.actions) && agentObj.actions.length) {
        await dtApplyCanvasActions(instanceId, agentObj.actions);
      } else {
        log("Agent lieferte keine Actions (actions-Array ist leer).");
      }

      try {
        // Nach den Actions Boardzustand nochmal scannen und neue Baseline setzen
        const ctx2 = await dtGetBoardBaseContext();
        await dtRebuildLiveCatalog(ctx2);
        const postState = await dtGetInstanceStateForAgent(instForState, {
          ctx: ctx2,
          liveCatalogReady: true
        });
        if (postState && postState.classification) {
          const nowIso = new Date().toISOString();
          instForState.baselineClassification = postState.classification;
          instForState.baselineStateJson = postState.stateJson;
          instForState.lastDiff = null;
          instForState.lastAgentRunAt = nowIso;
          instForState.lastChangedAt = nowIso;
        }
      } catch (e2) {
        log("Fehler beim Aktualisieren der Baseline nach Agent-Run: " + e2.message);
      }
    } catch (e) {
      log("Exception beim Agent-Run: " + e.message);
    }
  }

  // --------------------------------------------------------------------
  // Exporte ins window
  // --------------------------------------------------------------------
  window.dtInsertTemplateImage      = dtInsertTemplateImage;
  window.dtClassifyStickies         = dtClassifyStickies;
  window.dtCallOpenAI               = dtCallOpenAI;
  window.dtClusterSelection         = dtClusterSelection;
  window.dtRunAgentForInstance      = dtRunAgentForInstance;
  window.dtRunGlobalAgent           = dtRunGlobalAgent;

  </script>
</body>
</html>
