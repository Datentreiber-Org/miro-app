<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Miro + OpenAI Responses (Client-only Test)</title>
  <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
  <style>
    :root { --gap: 10px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; line-height:1.35; }
    .row { display:flex; gap:var(--gap); align-items:center; flex-wrap:wrap; margin-bottom: var(--gap); }
    .col { display:flex; flex-direction:column; gap:6px; }
    label { font-weight:600; }
    input[type="text"], input[type="password"], select, textarea {
      padding:8px; border:1px solid #ccc; border-radius:8px;
    }
    textarea { width: 100%; min-height: 100px; }
    button { padding:8px 12px; border:1px solid #ccc; border-radius:8px; cursor:pointer; }
    .muted { color:#666; }
    .ok { color:#047857; font-weight:600; }
    .warn { color:#b45309; font-weight:600; }
    .err { color:#b91c1c; font-weight:600; }
    .grid { display:grid; grid-template-columns: 1fr; gap: var(--gap); }
    @media (min-width: 860px) { .grid { grid-template-columns: 1fr 1fr; } }
    pre#out { white-space: pre-wrap; border:1px solid #eee; border-radius:10px; padding:10px; min-height:100px; }
    .inline { display:inline-flex; gap:8px; align-items:center; }
  </style>
</head>
<body>
  <h2>OpenAI Chat (ohne Server, nur zum Testen)</h2>
  <div class="muted" style="margin-bottom:8px">
    Hinweis: API-Key wird clientseitig verwendet. Für Produktion später Proxy (z. B. Cloud Run) einsetzen.
  </div>

  <div class="grid">
    <div class="col">
      <label>OpenAI API Key</label>
      <div class="row">
        <input id="key" type="password" placeholder="sk-..." style="flex:1" />
        <button id="toggleKey" type="button">anzeigen</button>
      </div>
      <div class="row">
        <label class="inline"><input id="remember" type="checkbox" /> auf diesem Browser speichern</label>
        <span id="keyStatus" class="muted"></span>
      </div>
    </div>

    <div class="col">
      <label>Modell</label>
      <div class="row" style="align-items:flex-start">
        <select id="model" style="min-width:240px">
          <option value="gpt-4.1">gpt-4.1</option>
          <option value="gpt-4o">gpt-4o</option>
          <option value="o3-mini">o3-mini</option>
          <option value="gpt-5">gpt-5</option>
          <option value="custom">Custom …</option>
        </select>
        <input id="modelCustom" type="text" placeholder="eigener Modellname" style="flex:1; display:none">
      </div>
      <div class="muted">Nur Modelle wählen, die in deinem Projekt verfügbar sind.</div>
    </div>
  </div>

  <div class="col" style="margin-top:12px">
    <label>System Prompt (optional)</label>
    <input id="sys" type="text" placeholder="z. B.: Du bist ein hilfreicher Assistent im Miro-Panel." />
  </div>

  <div class="col" style="margin-top:12px">
    <label>Nachricht</label>
    <textarea id="prompt" placeholder="Frag GPT …"></textarea>
  </div>

  <div class="row">
    <button id="ask">Ask GPT</button>
    <button id="toSticky">Antwort → Sticky</button>
    <button id="clear">Verlauf leeren</button>
    <span id="status" class="muted"></span>
  </div>

  <pre id="out"></pre>

  <script>
    // -------------------- Local Speicher (nur Browser) --------------------
    const LS_KEY = 'dt_openai_key';
    const LS_MODEL = 'dt_openai_model';
    const LS_MODEL_CUSTOM = 'dt_openai_model_custom';
    const LS_SYS = 'dt_openai_sys';

    const keyEl = document.getElementById('key');
    const rememberEl = document.getElementById('remember');
    const keyStatusEl = document.getElementById('keyStatus');
    const modelEl = document.getElementById('model');
    const modelCustomEl = document.getElementById('modelCustom');
    const sysEl = document.getElementById('sys');
    const promptEl = document.getElementById('prompt');
    const statusEl = document.getElementById('status');
    const outEl = document.getElementById('out');
    const askBtn = document.getElementById('ask');
    const toStickyBtn = document.getElementById('toSticky');
    const clearBtn = document.getElementById('clear');
    const toggleKeyBtn = document.getElementById('toggleKey');

    // Gesprächsverlauf (flüchtig im Panel)
    let chat = [];

    // Init: Key/Model/System aus localStorage
    (function init() {
      try {
        const savedKey = localStorage.getItem(LS_KEY);
        if (savedKey) {
          keyEl.value = savedKey;
          rememberEl.checked = true;
          keyStatusEl.textContent = 'Key aus lokalem Speicher geladen.';
        }
      } catch {}

      try {
        const savedModel = localStorage.getItem(LS_MODEL);
        const savedCustom = localStorage.getItem(LS_MODEL_CUSTOM);
        if (savedModel) {
          modelEl.value = savedModel;
          if (savedModel === 'custom') {
            modelCustomEl.style.display = '';
            if (savedCustom) modelCustomEl.value = savedCustom;
          }
        }
      } catch {}

      try {
        const savedSys = localStorage.getItem(LS_SYS);
        if (savedSys) sysEl.value = savedSys;
      } catch {}
    })();

    rememberEl.addEventListener('change', () => {
      if (!rememberEl.checked) {
        try { localStorage.removeItem(LS_KEY); } catch {}
        keyStatusEl.textContent = 'Key wird NICHT gespeichert.';
      } else {
        try {
          localStorage.setItem(LS_KEY, keyEl.value.trim());
          keyStatusEl.textContent = 'Key lokal gespeichert.';
        } catch {}
      }
    });

    keyEl.addEventListener('input', () => {
      if (rememberEl.checked) {
        try { localStorage.setItem(LS_KEY, keyEl.value.trim()); } catch {}
        keyStatusEl.textContent = keyEl.value.trim() ? 'Key lokal gespeichert.' : 'Kein Key gesetzt.';
      } else {
        keyStatusEl.textContent = keyEl.value.trim() ? 'Key nur im Speicher (nicht gespeichert).' : 'Kein Key gesetzt.';
      }
    });

    toggleKeyBtn.onclick = () => {
      keyEl.type = keyEl.type === 'password' ? 'text' : 'password';
      toggleKeyBtn.textContent = keyEl.type === 'password' ? 'anzeigen' : 'verbergen';
    };

    modelEl.addEventListener('change', () => {
      const v = modelEl.value;
      if (v === 'custom') {
        modelCustomEl.style.display = '';
      } else {
        modelCustomEl.style.display = 'none';
      }
      try { localStorage.setItem(LS_MODEL, v); } catch {}
    });

    modelCustomEl.addEventListener('input', () => {
      try { localStorage.setItem(LS_MODEL_CUSTOM, modelCustomEl.value.trim()); } catch {}
    });

    sysEl.addEventListener('input', () => {
      try { localStorage.setItem(LS_SYS, sysEl.value.trim()); } catch {}
    });

    function getSelectedModel() {
      const v = modelEl.value;
      if (v === 'custom') {
        const c = modelCustomEl.value.trim();
        return c || 'gpt-4.1';
      }
      return v;
    }

    // -------------------- Mapping: Rollen → Content-Typ --------------------
    // user/system -> input_text, assistant -> output_text
    function mapMessagesToResponsesInput(messages) {
      return messages.map(m => {
        const role = m.role;
        let type;
        if (role === 'assistant') {
          type = 'output_text';
        } else {
          // 'user' oder 'system'
          type = 'input_text';
        }
        return {
          role,
          content: [{ type, text: m.content }]
        };
      });
    }

    // -------------------- Responses API: SSE-Streaming --------------------
    async function streamResponse({ apiKey, model, messages, onDelta }) {
      const body = {
        model,
        input: mapMessagesToResponsesInput(messages),
        stream: true
      };

      const res = await fetch("https://api.openai.com/v1/responses", {
        method: "POST",
        headers: {
          "authorization": `Bearer ${apiKey}`,
          "content-type": "application/json"
        },
        body: JSON.stringify(body)
      });

      if (!res.ok || !res.body) {
        const t = await res.text().catch(()=> "");
        throw new Error("OpenAI request failed: " + res.status + " " + t);
      }

      const reader = res.body.getReader();
      const dec = new TextDecoder();

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        const chunk = dec.decode(value, { stream: true });

        for (const line of chunk.split("\n")) {
          const m = line.match(/^data:\s*(.*)$/);
          if (!m) continue;
          if (m[1] === "[DONE]") continue;

          try {
            const evt = JSON.parse(m[1]);
            if (evt.type === "response.output_text.delta") {
              onDelta(evt.delta);
            }
          } catch {}
        }
      }
    }

    // -------------------- UI-Logik --------------------
    askBtn.onclick = async () => {
      const apiKey = keyEl.value.trim();
      const model = getSelectedModel();
      const sys = sysEl.value.trim();
      const user = promptEl.value.trim();

      if (!apiKey) { statusEl.textContent = 'Bitte API Key eingeben.'; return; }
      if (!user)   { statusEl.textContent = 'Bitte eine Nachricht eingeben.'; return; }

      // Gesprächsverlauf zusammenbauen
      const msgs = [];
      if (sys) msgs.push({ role: "system", content: sys });
      for (const m of chat) msgs.push(m);
      msgs.push({ role: "user", content: user });

      // Anzeige reset
      outEl.textContent = '';
      statusEl.textContent = `Frage wird verarbeitet … (Modell: ${model})`;

      try {
        let full = "";
        await streamResponse({
          apiKey,
          model,
          messages: msgs,
          onDelta: (delta) => {
            full += delta;
            outEl.textContent += delta;
          }
        });
        statusEl.textContent = 'Fertig.';

        // Verlauf pflegen: aktuelle User- und Assistant-Nachricht anhängen
        chat.push({ role: "user", content: user });
        chat.push({ role: "assistant", content: outEl.textContent });

      } catch (e) {
        statusEl.textContent = 'Fehler: ' + e.message;
      }
    };

    toStickyBtn.onclick = async () => {
      const text = outEl.textContent.trim();
      if (!text) return;
      const sticky = await miro.board.createStickyNote({
        content: `<p>${text
          .replace(/&/g,'&amp;')
          .replace(/</g,'&lt;')
          .replace(/\n/g,'<br>')}</p>`
      });
      await miro.board.viewport.zoomTo(sticky);
    };

    clearBtn.onclick = () => {
      chat = [];
      outEl.textContent = '';
      statusEl.textContent = 'Verlauf geleert.';
    };
  </script>
</body>
</html>
