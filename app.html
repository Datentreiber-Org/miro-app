<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Datentreiber – Template Mapper</title>
  <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 12px;
      font-size: 13px;
    }
    h3 {
      margin-top: 0;
      font-size: 15px;
    }
    h4 {
      margin: 8px 0 4px;
      font-size: 13px;
    }
    .block {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 8px;
    }
    button {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #f5f5f5;
      cursor: pointer;
      font-size: 12px;
      margin-right: 6px;
      margin-top: 4px;
    }
    button:hover {
      background: #eee;
    }
    label {
      display: block;
      margin: 4px 0;
    }
    input[type="password"],
    select,
    textarea {
      width: 100%;
      box-sizing: border-box;
      font-size: 12px;
      margin-top: 2px;
      padding: 4px;
    }
    textarea {
      resize: vertical;
    }
    .hint {
      color: #666;
      font-size: 11px;
      margin: 0 0 4px;
    }
    #log {
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 11px;
      white-space: pre-wrap;
      background: #fafafa;
      border: 1px solid #eee;
      border-radius: 6px;
      padding: 6px;
      max-height: 260px;
      overflow: auto;
    }
  </style>
</head>
<body>
  <div id="app">
    <h3>Datentreiber Bot Beta V.1.0</h3>

    <div class="block">
      <h4>1) Template wählen</h4>
      <p class="hint">
        „Template-Bild auf Board einfügen“ legt dein 3-Boxes-PNG als Bild aufs Board
        und registriert eine Canvas-Instanz inkl. eines Action-Shape-Buttons direkt unter dem Canvas ([DT] AI).<br>
        „Aktuelle Auswahl als Template setzen“ ist vor allem für die Entwicklungsphase da:
        ein ausgewähltes 3-Boxes-PNG wird als Instanz registriert.<br>
        Beim Klassifizieren / GPT-Call werden die Instanzen intern per Image-Rect und Koordinaten erkannt.
      </p>
      <button onclick="window.dtInsertTemplateImage()">Template-Bild auf Board einfügen</button>
      <button onclick="window.dtSetTemplateFromSelection()">Aktuelle Auswahl als Template setzen</button>
      <button onclick="window.dtClassifyStickies()">Stickies klassifizieren</button>
      <button onclick="window.dtClusterSelection()">Auswahl clustern (unterstrichener Text = Clustername)</button>
    </div>

    <div class="block">
      <h4>2) GPT-Abfrage (Side-Panel / Debug)</h4>
      <label>
        OpenAI API Key:
        <input id="api-key" type="password" placeholder="sk-..." autocomplete="off">
      </label>
      <label>
        Modell:
        <select id="model">
          <option value="gpt-4.1-mini">gpt-4.1-mini</option>
          <option value="gpt-4.1">gpt-4.1</option>
          <option value="o3-mini">o3-mini</option>
        </select>
      </label>
      <label>
        Frage / Aufgabe an GPT:
        <textarea id="user-text" rows="3"
          placeholder="Bitte analysiere die Sticky Notes auf dem 3-Boxes-Canvas ..."></textarea>
      </label>
      <button onclick="window.dtCallOpenAI()">An GPT senden (inkl. aktueller Klassifikation)</button>
      <p class="hint">
        Hinweis: Der Shape-Button auf dem Board („[DT] AI – inst-X“) startet einen instanzspezifischen Agentenlauf
        mit eigener JSON-Action-Ausgabe und Board-Manipulation.
      </p>
    </div>

    <div class="block">
      <h4>Debug / Ausgabe</h4>
      <pre id="log"></pre>
    </div>
  </div>

  <script>
    // --------------------------------------------------------------------
    // Konfiguration
    // --------------------------------------------------------------------
    const TEMPLATE_ID = "datentreiber-3boxes";
    const TEMPLATE_IMAGE_URL =
      "https://www.datentreiber.com/wp-content/uploads/2024/12/Datentreiber_EN_3-Boxes_v1-1_20240610.png";
    const CLUSTER_META_KEY = "datentreiber-clusters";

    // Instanz-Management (alle 3-Boxes-Bilder auf dem Board)
    let currentTemplateImage = null;   // {id, title, x, y, width, height} (Legacy/Fallback)
    let lastClassification = null;
    let miroReadyPromise = null;

    let dtInitialized = false;
    let dtNextInstanceCounter = 1;

    // imageId -> instance
    // instanceId -> instance
    const dtInstancesByImageId = new Map();
    const dtInstancesById = new Map();

    // Cluster-Zuordnung: Sticky-ID -> Cluster-Name (nur Panel-Session)
    const dtClusterAssignments = new Map();

    // Schutzflag, um rekursive selection:update-Events zu vermeiden
    let dtHandlingSelection = false;

    // Automatische Cluster-Namen (Fallback), Zähler pro Instanz
    const dtClusterCounterByInstanceId = new Map();
    let dtGlobalClusterCounter = 1;

    // Sehr einfacher Prompt-Katalog (später erweiterbar für 25 Canvas-Typen)
    const DT_PROMPT_CATALOG = {
      [TEMPLATE_ID]: {
        system: (
          "Du bist ein Facilitation-Bot für Miro-Workshops.\n" +
          "Du siehst:\n" +
          "- eine aktive Canvas-Instanz (3-Boxes-Canvas) mit allen Sticky Notes als JSON\n" +
          "- einen Board-Katalog mit allen weiteren Instanzen (nur als Zusammenfassung).\n" +
          "Du sollst:\n" +
          "1) die Situation auf der aktiven Instanz verstehen (Input / Processing / Output),\n" +
          "2) sinnvolle nächste Schritte vorschlagen und\n" +
          "3) optionale Board-Aktionen als JSON liefern (z.B. Stickies verschieben oder anlegen).\n" +
          "WICHTIG: Antworte ausschließlich mit einem JSON-Objekt im folgenden Format:\n" +
          "{\n" +
          '  "analysis": "kurze Erklärung in natürlicher Sprache",\n' +
          '  "actions": [\n' +
          '    { "type": "move_sticky", "stickyId": "id", "targetArea": "Box 2 (Mitte)" },\n' +
          '    { "type": "create_sticky", "area": "Box 3 (rechts)", "text": "Neuer Inhalt" },\n' +
          '    { "type": "delete_sticky", "stickyId": "id" }\n' +
          "  ]\n" +
          "}\n" +
          "Falls du keine Aktionen vorschlagen möchtest, setze actions auf ein leeres Array []."
        )
      }
    };

    // --------------------------------------------------------------------
    // Logging & Helper
    // --------------------------------------------------------------------
    function log(msg) {
      const el = document.getElementById("log");
      const text = typeof msg === "string" ? msg : JSON.stringify(msg, null, 2);
      el.textContent = (el.textContent ? el.textContent + "\n\n" : "") + text;
      el.scrollTop = el.scrollHeight;
    }

    // Beim Laden sofort sichtbar machen, dass JS läuft:
    (function initialLog() {
      const el = document.getElementById("log");
      if (el) {
        el.textContent =
          "Panel-JS geladen: " + new Date().toLocaleTimeString() +
          "\nWarte auf Miro SDK (dtEnsureMiroReady) ...";
      }
      console.log("[DT] app.html Script geladen");
    })();

    window.onerror = function (msg, src, line, col, err) {
      log("JS-Fehler: " + msg + " @ " + line + ":" + col);
    };

    function stripHtml(html) {
      if (!html) return "";
      const tmp = document.createElement("div");
      tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || "";
    }

    // Unterstrichenen Text aus dem Sticky-HTML extrahieren (für Cluster-Namen)
    function dtExtractUnderlinedText(html) {
      if (!html) return null;
      const tmp = document.createElement("div");
      tmp.innerHTML = html;
      const u = tmp.querySelector("u");
      if (!u) return null;
      const txt = (u.textContent || "").trim();
      return txt || null;
    }

    function dtGetCurrentUserQuestion() {
      const el = document.getElementById("user-text");
      const t = el && el.value ? el.value.trim() : "";
      if (t) return t;
      return "Bitte analysiere diese Canvas-Instanz und führe sinnvolle nächste Schritte innerhalb des Workshop-Workflows aus.";
    }

    // --------------------------------------------------------------------
    // Miro-Ready-Helfer (einmalig)
    // --------------------------------------------------------------------
    function dtEnsureMiroReady() {
      if (!miroReadyPromise) {
        miroReadyPromise = new Promise((resolve) => {
          const onReady = () => {
            console.log("[DT] Miro SDK v2 bereit");
            log("Miro SDK bereit.");
            dtAfterMiroReady();
            resolve();
          };

          if (window.miro && typeof window.miro.board !== "undefined") {
            onReady();
          } else if (window.miro && typeof window.miro.onReady === "function") {
            window.miro.onReady(onReady);
          } else {
            log("Warnung: miro.onReady nicht verfügbar, versuche SDK direkt zu verwenden.");
            dtAfterMiroReady();
            resolve();
          }
        });
      }
      return miroReadyPromise;
    }

    async function dtAfterMiroReady() {
      if (dtInitialized) return;
      dtInitialized = true;

      try {
        await dtScanTemplateInstances();
      } catch (e) {
        console.error("[DT] Fehler beim initialen Template-Scan:", e);
      }

      try {
        if (miro.board && miro.board.ui && typeof miro.board.ui.on === "function") {
          // Wir nutzen selection:update als Trigger für unseren AI-Shape-Button
          miro.board.ui.on("selection:update", dtOnSelectionUpdate);
        }
      } catch (e) {
        console.error("[DT] Fehler bei Registrierung von UI-Events:", e);
        log("Fehler bei Registrierung von UI-Events: " + e.message);
      }
    }

    // --------------------------------------------------------------------
    // Instanz-Management
    // --------------------------------------------------------------------
    async function dtCreateInstanceActionShapes(instance, image) {
      if (!miro.board || !miro.board.createShape) {
        return;
      }

      const baseY = image.y + image.height / 2 + 80;
      const baseX = image.x;
      const dx = 260;

      const aiShape = await miro.board.createShape({
        content: `[DT] AI – ${instance.instanceId}`,
        shape: "round_rectangle",
        x: baseX - dx / 2,
        y: baseY,
        width: 260,
        height: 60
      });

      instance.actionItems = {
        aiItemId: aiShape.id
      };
    }

    async function dtRegisterInstanceFromImage(image) {
      if (!image || !image.id) return null;

      let instance = dtInstancesByImageId.get(image.id);
      if (instance) {
        // Geometrie aktualisieren
        instance.title = image.title || instance.title || "Datentreiber 3-Boxes";
        instance.lastGeometry = {
          x: image.x,
          y: image.y,
          width: image.width,
          height: image.height
        };
        return instance;
      }

      const instanceId = "inst-" + (dtNextInstanceCounter++);
      instance = {
        instanceId,
        canvasTypeId: TEMPLATE_ID,
        imageId: image.id,
        title: image.title || "Datentreiber 3-Boxes",
        lastGeometry: {
          x: image.x,
          y: image.y,
          width: image.width,
          height: image.height
        },
        lastClassification: null,
        lastStateJson: null,
        lastStickyCount: 0,
        lastChangedAt: null,
        lastDiff: null,
        actionItems: {}
      };

      dtInstancesByImageId.set(image.id, instance);
      dtInstancesById.set(instanceId, instance);

      log("Neue Canvas-Instanz registriert: " + instanceId + " (Bild-ID " + image.id + ")");
      try {
        await dtCreateInstanceActionShapes(instance, image);
      } catch (e) {
        console.error("[DT] Fehler beim Erzeugen der Action-Shapes:", e);
      }

      return instance;
    }

    async function dtScanTemplateInstances() {
      if (!miro.board || !miro.board.get) return;
      // Wenn bereits Instanzen bekannt sind, trotzdem einmal scannen, um ggf. neue zu erfassen.
      let images = [];
      try {
        images = await miro.board.get({ type: "image" });
      } catch (e) {
        console.error("[DT] Fehler beim Laden der Images:", e);
        return;
      }
      if (!Array.isArray(images)) return;

      for (const img of images) {
        if (
          img.type === "image" &&
          typeof img.url === "string" &&
          img.url.indexOf(TEMPLATE_IMAGE_URL) !== -1
        ) {
          await dtRegisterInstanceFromImage(img);
        }
      }
    }

    function dtDiffHasChanges(diff) {
      if (!diff) {
        return false;
      }
      const createdCount = Array.isArray(diff.created) ? diff.created.length : 0;
      const deletedCount = Array.isArray(diff.deleted) ? diff.deleted.length : 0;
      const updatedCount = Array.isArray(diff.updated) ? diff.updated.length : 0;
      return createdCount > 0 || deletedCount > 0 || updatedCount > 0;
    }

    function dtBuildBoardCatalogSummary(activeInstanceId) {
      const instances = [];
      dtInstancesById.forEach((instance, id) => {
        const diff = instance.lastDiff;
        const hasChanges = dtDiffHasChanges(diff);

        const entry = {
          instanceId: id,
          canvasTypeId: instance.canvasTypeId,
          title: instance.title,
          imageId: instance.imageId,
          lastStickyCount: instance.lastStickyCount || 0,
          lastChangedAt: instance.lastChangedAt,
          headerSummary:
            instance.lastClassification &&
            instance.lastClassification.template &&
            instance.lastClassification.template.headerSummary
              ? instance.lastClassification.template.headerSummary
              : null,
          isActive: (id === activeInstanceId) || hasChanges,
          changesSinceLastAgent: hasChanges
            ? {
                created: diff.created || [],
                deleted: diff.deleted || [],
                updated: diff.updated || []
              }
            : null
        };
        instances.push(entry);
      });
      return { instances };
    }

    function dtFindInstanceForPoint(x, y) {
      let foundInstance = null;

      dtInstancesById.forEach(function (instance) {
        const geom = instance.lastGeometry;
        if (!geom) {
          return;
        }

        const left = geom.x - geom.width / 2;
        const top = geom.y - geom.height / 2;
        const right = geom.x + geom.width / 2;
        const bottom = geom.y + geom.height / 2;

        if (x >= left && x <= right && y >= top && y <= bottom) {
          if (!foundInstance) {
            foundInstance = instance;
          }
        }
      });

      return foundInstance;
    }

    async function dtOnSelectionUpdate(event) {
      if (dtHandlingSelection) {
        return;
      }

      const items = event && event.items ? event.items : [];

      if (items.length !== 1) {
        return;
      }

      const item = items[0];
      if (item.type !== "shape") {
        return;
      }

      const text = stripHtml(item.content || "");
      if (text.indexOf("[DT]") !== 0) {
        return;
      }

      const aiMatch = text.match(/^\[DT\]\s*AI\s*–\s*(.+)$/);
      if (!aiMatch) {
        return;
      }

      const instanceId = aiMatch[1].trim();

      dtHandlingSelection = true;
      try {
        log("Agent-Button (Shape) für Instanz " + instanceId + " ausgelöst.");
        await dtRunAgentForInstance(instanceId);
      } finally {
        dtHandlingSelection = false;
      }
    }

    // --------------------------------------------------------------------
    // Mapping von normalisierten Koordinaten -> Regionen (3 Boxen)
    // --------------------------------------------------------------------
    function dtMapToRegion(px, py) {
      // Vertikale Begrenzung grob: unterhalb des Headers, oberhalb Fußzeile
      const yMin = 0.20;
      const yMax = 0.95;
      if (py < yMin || py > yMax) return null;
      if (px < 0 || px > 1) return null;

      const third = 1 / 3;
      if (px < third) {
        return { id: "left",   title: "Box 1 (links)" };
      } else if (px < 2 * third) {
        return { id: "middle", title: "Box 2 (Mitte)" };
      } else {
        return { id: "right",  title: "Box 3 (rechts)" };
      }
    }

    function dtAreaNameToRegion(areaName) {
      if (!areaName) return null;
      const norm = areaName.toLowerCase();
      if (norm.indexOf("box 1") !== -1 || norm.indexOf("links") !== -1) {
        return { id: "left", title: "Box 1 (links)" };
      }
      if (norm.indexOf("box 2") !== -1 || norm.indexOf("mitte") !== -1) {
        return { id: "middle", title: "Box 2 (Mitte)" };
      }
      if (norm.indexOf("box 3") !== -1 || norm.indexOf("rechts") !== -1) {
        return { id: "right", title: "Box 3 (rechts)" };
      }
      return null;
    }

    // Sehr grob: Rolle aus Y-Position ableiten (Header / Body / Footer)
    function dtRoleFromNormalizedY(py) {
      if (py < 0.20) return "header";  // oberer Streifen über den drei Boxen
      if (py > 0.95) return "footer";  // unterer Streifen
      return "body";
    }

    // --------------------------------------------------------------------
    // Board-Kontext (für Klassifikation & Agent)
    // --------------------------------------------------------------------
    async function dtGetBoardBaseContext() {
      await dtEnsureMiroReady();
      try {
        const [stickies, connectors, tags] = await Promise.all([
          miro.board.get({ type: "sticky_note" }),
          miro.board.get({ type: "connector" }),
          miro.board.get({ type: "tag" })
        ]);

        const tagsById = {};
        if (Array.isArray(tags)) {
          for (const tag of tags) {
            const title = tag.title || tag.text || tag.content || "";
            tagsById[tag.id] = title;
          }
        }
        return { stickies: stickies || [], connectors: connectors || [], tagsById };
      } catch (e) {
        log("Fehler beim Laden des Board-Kontexts: " + e.message);
        return { stickies: [], connectors: [], tagsById: {} };
      }
    }

    // --------------------------------------------------------------------
    // 1A) Template-Bild neu einfügen
    // --------------------------------------------------------------------
    async function dtInsertTemplateImage() {
      log("Button: Template-Bild auf Board einfügen (klick).");
      await dtEnsureMiroReady();

      try {
        const image = await miro.board.createImage({
          url: TEMPLATE_IMAGE_URL,
          x: 0,
          y: 0,
          width: 2000
        });

        currentTemplateImage = {
          id: image.id,
          title: image.title || "Datentreiber 3-Boxes",
          x: image.x,
          y: image.y,
          width: image.width,
          height: image.height
        };
        lastClassification = null;

        await dtRegisterInstanceFromImage(image);

        log(
          "Template eingefügt: Bild-ID " + image.id +
          " / " + currentTemplateImage.title +
          "\nDu kannst das Bild nun verschieben oder skalieren.\n" +
          "Unterhalb des Canvas findest du einen Shape-Button:\n" +
          "- [DT] AI – startet den Agenten für diese Instanz (Shape anklicken)\n" +
          "\nZum Clustern verwende den Button 'Auswahl clustern' im Side-Panel. " +
          "Er wirkt nur auf Sticky Notes innerhalb genau einer Canvas-Instanz."
        );
        await miro.board.viewport.zoomTo(image);
      } catch (e) {
        log("Fehler beim Einfügen des Template-Bildes: " + e.message);
      }
    }

    // --------------------------------------------------------------------
    // 1B) Template aus aktueller Auswahl setzen (manuelle Fokussierung)
    // --------------------------------------------------------------------
    async function dtSetTemplateFromSelection() {
      log("Button: Aktuelle Auswahl als Template setzen (klick).");
      await dtEnsureMiroReady();

      try {
        const selection = await miro.board.getSelection();
        if (!selection.length) {
          log("Kein Element ausgewählt. Bitte das Template-PNG auf dem Board anklicken (blau markiert) und erneut versuchen.");
          return;
        }

        const image = selection.find((item) => item.type === "image" &&
          typeof item.url === "string" &&
          item.url.indexOf(TEMPLATE_IMAGE_URL) !== -1
        );
        if (!image) {
          log("In der Auswahl ist kein passendes 3-Boxes-Bild-Element. Bitte direkt das Template-PNG auswählen (nicht den Frame).");
          return;
        }

        currentTemplateImage = {
          id: image.id,
          title: image.title || "Datentreiber 3-Boxes",
          x: image.x,
          y: image.y,
          width: image.width,
          height: image.height
        };
        lastClassification = null;

        await dtRegisterInstanceFromImage(image);

        log("Template gesetzt aus Auswahl: Bild-ID " + image.id +
            " / " + currentTemplateImage.title +
            "\n(Hinweis: In Zukunft wird die Template-Auswahl nur noch über das Side-Panel / Template-Bibliothek erfolgen.)");
      } catch (e) {
        log("Fehler beim Setzen des Templates aus Auswahl: " + e.message);
      }
    }

    // --------------------------------------------------------------------
    // Auswahl clustern:
    //  - Auswahl muss Sticky Notes enthalten
    //  - genau EIN Sticky mit unterstrichenem Text = Cluster-Name (optional)
    //  - Fallback: generischer Clustername, wenn kein unterstrichener Text
    //  - nur Sticky Notes innerhalb genau EINER Canvas-Instanz
    // --------------------------------------------------------------------
    async function dtClusterSelectionWithIds(stickyIds) {
      await dtEnsureMiroReady();
      await dtScanTemplateInstances();

      try {
        let stickyNotes = [];

        if (Array.isArray(stickyIds) && stickyIds.length > 0) {
          const arr = await miro.board.get({ id: stickyIds });
          if (Array.isArray(arr)) {
            stickyNotes = arr.filter(function (it) { return it.type === "sticky_note"; });
          } else if (arr && arr.type === "sticky_note") {
            stickyNotes = [arr];
          }
        } else {
          const selection = await miro.board.getSelection();
          if (!selection || !selection.length) {
            log("Keine Auswahl gefunden. Bitte einige Sticky Notes auswählen.");
            return;
          }
          stickyNotes = selection.filter(function (item) { return item.type === "sticky_note"; });
        }

        if (!stickyNotes.length) {
          log("In der Auswahl sind keine Sticky Notes. Bitte nur Sticky Notes auswählen.");
          return;
        }

        const byInstance = {};
        const outside = [];

        stickyNotes.forEach(function (s) {
          const instance = dtFindInstanceForPoint(s.x, s.y);
          if (!instance) {
            outside.push(s);
            return;
          }
          const id = instance.instanceId;
          if (!byInstance[id]) {
            byInstance[id] = [];
          }
          byInstance[id].push(s);
        });

        const instanceIds = Object.keys(byInstance);

        if (outside.length > 0) {
          log(
            "Die Auswahl enthält Sticky Notes, die nicht über einem 3-Boxes-Canvas liegen. " +
            "Bitte nur Sticky Notes innerhalb einer Canvas-Instanz auswählen."
          );
          return;
        }

        if (!instanceIds.length) {
          log(
            "Keine der ausgewählten Sticky Notes liegt über einem 3-Boxes-Canvas. " +
            "Bitte zuerst das Template verwenden und die Sticky Notes innerhalb des Canvas platzieren."
          );
          return;
        }

        if (instanceIds.length > 1) {
          log(
            "Die Auswahl enthält Sticky Notes aus mehreren Canvas-Instanzen. " +
            "Bitte nur Sticky Notes aus genau einer Instanz gleichzeitig clustern."
          );
          return;
        }

        const instanceId = instanceIds[0];
        const notesInInstance = byInstance[instanceId];

        // 1) Sticky mit unterstrichenem Text als Cluster-Name finden (optional)
        let headerSticky = null;
        for (const s of notesInInstance) {
          const html = s.content || "";
          if (
            html.indexOf("<u>") !== -1 ||
            html.indexOf("text-decoration:underline") !== -1
          ) {
            headerSticky = s;
            break;
          }
        }

        let clusterName = null;

        if (headerSticky) {
          const candidate = stripHtml(headerSticky.content).trim();
          if (!candidate) {
            log(
              "Der unterstrichene Sticky-Text ist leer. " +
              "Bitte einen lesbaren Namen unterstreichen oder ohne Unterstreichung arbeiten, " +
              "dann wird ein generischer Clustername vergeben."
            );
            return;
          }
          clusterName = candidate;
        } else {
          // Fallback: generischer Clustername, wenn kein unterstrichener Text vorhanden ist
          let count = dtClusterCounterByInstanceId.get(instanceId) || 0;
          count += 1;
          dtClusterCounterByInstanceId.set(instanceId, count);
          clusterName = "Cluster " + count;
        }

        // 2) Session-State: alle betroffenen Stickies auf diesen Cluster setzen
        for (const s of notesInInstance) {
          dtClusterAssignments.set(s.id, clusterName);
        }

        log(
          "Cluster '" +
          clusterName +
          "' gesetzt für " +
          notesInInstance.length +
          " Sticky Notes (Session-State, kein Board-Metafeld)."
        );
      } catch (e) {
        log("Fehler beim Setzen der Cluster-Metadaten: " + e.message);
      }
    }

    async function dtClusterSelection() {
      log("Button: Auswahl clustern (klick).");
      await dtClusterSelectionWithIds(null);
    }

    // --------------------------------------------------------------------
    // 2a) Klassifikation für EIN Template (intern)
    //      - inkl. Farbe, Tags und Verbindungen
    // --------------------------------------------------------------------
    function dtClassifyStickiesForTemplate(template, ctx) {
      const t = template;
      const left = t.x - t.width / 2;
      const top  = t.y - t.height / 2;

      const result = {
        template: {
          id: TEMPLATE_ID,
          name: t.title,
          imageId: t.id,
          headerSummary: null
        },
        header: {
          stickies: []
        },
        counts: {
          total: 0,
          byRegion: {}
        },
        items: [],
        connections: []
      };

      const stickyMap = new Map();

      // --- Stickies einsammeln ------------------------------------------------
      for (const s of ctx.stickies) {
        const sx = s.x;
        const sy = s.y;

        const px = (sx - left) / t.width;
        const py = (sy - top) / t.height;
        const inImageRect = px >= 0 && px <= 1 && py >= 0 && py <= 1;

        if (!inImageRect) {
          // außerhalb dieses Template-Bildes -> ignorieren
          continue;
        }

        const role = dtRoleFromNormalizedY(py);

        let regionId = null;
        let regionTitle = null;
        if (role === "body") {
          const region = dtMapToRegion(px, py);
          if (region) {
            regionId = region.id;
            regionTitle = region.title;
          }
        }

        result.counts.total += 1;
        if (regionId) {
          result.counts.byRegion[regionId] =
            (result.counts.byRegion[regionId] || 0) + 1;
        }

        const cleanText = stripHtml(s.content);
        const color =
          (s.style && (s.style.fillColor || s.style.backgroundColor)) || null;
        const tagIds = Array.isArray(s.tagIds) ? s.tagIds.slice() : [];
        const tags =
          tagIds && tagIds.length && ctx.tagsById
            ? tagIds
                .map((id) => ({
                  id,
                  title: ctx.tagsById[id] || null
                }))
                .filter((t) => t.id)
            : [];

        const item = {
          stickyId: s.id,
          text: cleanText,
          px: Math.round(px * 10000) / 10000,
          py: Math.round(py * 10000) / 10000,
          inImageRect,
          role,
          regionId,
          regionTitle,
          color,
          tagIds,
          tags,
          // Cluster-Zuordnung aus dem Session-State (dtClusterSelection)
          clusterName: dtClusterAssignments.get(s.id) || null,
          connectionsOut: [],
          connectionsIn: []
        };

        result.items.push(item);
        stickyMap.set(s.id, item);

        if (role === "header") {
          result.header.stickies.push({
            stickyId: s.id,
            text: cleanText,
            px: item.px,
            py: item.py,
            color,
            tagIds,
            tags
          });
        }
      }

      // Header-Text grob zusammenfassen, damit jede Instanz identifizierbar ist
      if (result.header.stickies.length) {
        const pieces = result.header.stickies
          .map((h) => h.text)
          .filter(Boolean);
        if (pieces.length) {
          const joined = pieces.join(" | ");
          result.template.headerSummary =
            joined.length > 200 ? joined.slice(0, 197) + "..." : joined;
        }
      }

      // --- Connector-Beziehungen zwischen Stickies innerhalb dieses Templates
      if (ctx.connectors && ctx.connectors.length) {
        for (const c of ctx.connectors) {
          const startId = c.start && c.start.item;
          const endId   = c.end   && c.end.item;
          if (!startId || !endId) continue;

          const fromItem = stickyMap.get(startId);
          const toItem   = stickyMap.get(endId);
          if (!fromItem || !toItem) continue; // mind. ein Ende nicht in diesem Template

          const conn = {
            connectorId: c.id,
            fromStickyId: startId,
            toStickyId: endId
          };

          if (c.shape) {
            conn.shape = c.shape;
          }
          if (c.style) {
            const style = {};
            if (typeof c.style.startStrokeCap !== "undefined") {
              style.startStrokeCap = c.style.startStrokeCap;
            }
            if (typeof c.style.endStrokeCap !== "undefined") {
              style.endStrokeCap = c.style.endStrokeCap;
            }
            if (typeof c.style.strokeColor !== "undefined") {
              style.strokeColor = c.style.strokeColor;
            }
            if (Object.keys(style).length) {
              conn.style = style;
            }
          }

          result.connections.push(conn);
          fromItem.connectionsOut.push({
            connectorId: c.id,
            toStickyId: endId
          });
          toItem.connectionsIn.push({
            connectorId: c.id,
            fromStickyId: startId
          });
        }
      }

      return result;
    }

    // --------------------------------------------------------------------
    // 2b) Stickies klassifizieren (für 1..n Templates)
    //     - Kann manuell (Button) oder „silent“ aus dtCallOpenAI aufgerufen werden
    // --------------------------------------------------------------------
    async function dtResolveTemplateImages(options) {
      const silent = options && options.silent;
      await dtEnsureMiroReady();

      let selection = [];
      try {
        selection = await miro.board.getSelection();
      } catch (e) {
        if (!silent) {
          log("Fehler beim Lesen der Auswahl: " + e.message);
        }
      }

      // 1) Alle ausgewählten 3-Boxes-Bilder als Templates verwenden
      if (selection && selection.length) {
        const images = selection.filter(
          (item) =>
            item.type === "image" &&
            typeof item.url === "string" &&
            item.url.indexOf(TEMPLATE_IMAGE_URL) !== -1
        );

        if (images.length) {
          const templates = images.map((img) => ({
            id: img.id,
            title: img.title || "Datentreiber 3-Boxes",
            x: img.x,
            y: img.y,
            width: img.width,
            height: img.height
          }));

          // Für Abwärtskompatibilität: erste Instanz merken
          currentTemplateImage = templates[0];

          if (!silent) {
            if (templates.length === 1) {
              log(
                "Template aus Auswahl verwendet: Bild-ID " +
                templates[0].id + " / " + templates[0].title
              );
            } else {
              log(
                "Mehrere Template-Bilder aus Auswahl verwendet (" +
                templates.length + " Stück)."
              );
            }
          }
          return templates;
        }
      }

      // 2) Fallback: gespeichertes Template-Bild anhand seiner ID vom Board holen
      if (!currentTemplateImage || !currentTemplateImage.id) {
        if (!silent) {
          log(
            "Kein Template gesetzt und keine passende Bild-Auswahl vorhanden. " +
            "Bitte zuerst ein 3-Boxes-PNG einfügen oder auswählen."
          );
        }
        return [];
      }

      try {
        const arr = await miro.board.get({ id: currentTemplateImage.id });
        const img = Array.isArray(arr) ? arr[0] : arr;

        if (!img) {
          if (!silent) {
            log("Das gespeicherte Template-Bild existiert nicht mehr auf dem Board.");
          }
          return [];
        }

        const t = {
          id: img.id,
          title: img.title || currentTemplateImage.title || "Datentreiber 3-Boxes",
          x: img.x,
          y: img.y,
          width: img.width,
          height: img.height
        };

        currentTemplateImage = t;

        if (!silent) {
          log(
            "Template aus gespeicherter Referenz verwendet: Bild-ID " +
            t.id + " / " + t.title
          );
        }

        return [t];
      } catch (e) {
        if (!silent) {
          log("Fehler beim Laden des gespeicherten Template-Bildes: " + e.message);
        }
        return [];
      }
    }

    async function dtClassifyStickies(options) {
      const silent = options && options.silent;
      if (!silent) {
        log("Button: Stickies klassifizieren (klick).");
      }

      await dtEnsureMiroReady();

      const templates = await dtResolveTemplateImages({ silent });
      if (!templates || !templates.length) {
        if (!silent) {
          log(
            "Es konnten keine Template-Bilder ermittelt werden. " +
            "Bitte wähle mindestens ein 3-Boxes-PNG aus oder füge eines ein."
          );
        }
        return null;
      }

      try {
        const ctx = await dtGetBoardBaseContext();
        const results = templates.map((t) =>
          dtClassifyStickiesForTemplate(t, ctx)
        );

        lastClassification =
          results.length === 1 ? results[0] : { templates: results };

        if (!silent) {
          if (results.length === 1) {
            log("Klassifikation fertig (1 Template):");
            log(lastClassification);
          } else {
            log("Klassifikation fertig für " + results.length + " Templates:");
            log(lastClassification);
          }
        }

        return lastClassification;
      } catch (e) {
        if (!silent) {
          log("Fehler bei der Klassifikation: " + e.message);
        } else {
          console.error("[DT] Fehler bei der Klassifikation (silent):", e);
        }
        return null;
      }
    }

    // --------------------------------------------------------------------
    // 2c) Reduziertes JSON für das Sprachmodell aus der Klassifikation bauen
    // --------------------------------------------------------------------
    function dtBuildPromptPayloadFromClassification(classification) {
      if (!classification) {
        return null;
      }

      const perTemplate = Array.isArray(classification.templates) && classification.templates.length
        ? classification.templates
        : [classification];

      function transformOne(one) {
        const idToItem = {};
        if (Array.isArray(one.items)) {
          for (const item of one.items) {
            if (item && item.stickyId) {
              idToItem[item.stickyId] = item;
            }
          }
        }

        function buildConnectionsOut(item) {
          const result = [];
          if (!item || !Array.isArray(item.connectionsOut)) {
            return result;
          }
          for (const co of item.connectionsOut) {
            const target = co && idToItem[co.toStickyId];
            const toText = target ? target.text : null;
            const toArea = target
              ? (target.regionTitle || (target.role === "header" ? "Header" : null))
              : null;
            result.push({
              connectorId: co.connectorId,
              toText: toText,
              toArea: toArea
            });
          }
          return result;
        }

        function buildConnectionsIn(item) {
          const result = [];
          if (!item || !Array.isArray(item.connectionsIn)) {
            return result;
          }
          for (const ci of item.connectionsIn) {
            const source = ci && idToItem[ci.fromStickyId];
            const fromText = source ? source.text : null;
            const fromArea = source
              ? (source.regionTitle || (source.role === "header" ? "Header" : null))
              : null;
            result.push({
              connectorId: ci.connectorId,
              fromText: fromText,
              fromArea: fromArea
            });
          }
          return result;
        }

        const headerStickiesRaw =
          (one.header && Array.isArray(one.header.stickies) && one.header.stickies) || [];

        const header = {
          summary: one.template && one.template.headerSummary,
          stickies: headerStickiesRaw.map(function (h) {
            const item = h.stickyId ? idToItem[h.stickyId] : null;
            const tagObjs = item && Array.isArray(item.tags)
              ? item.tags
              : (Array.isArray(h.tags) ? h.tags : []);
            const tags = tagObjs
              .map(function (t) { return t && t.title; })
              .filter(function (title) { return !!title; });

            return {
              text: h.text,
              color: (item && item.color) || h.color || null,
              tags: tags,
              clusterName: item && item.clusterName ? item.clusterName : null,
              connectionsOut: buildConnectionsOut(item),
              connectionsIn: buildConnectionsIn(item)
            };

          })
        };

        const areasByName = {};

        if (Array.isArray(one.items)) {
          for (const item of one.items) {
            if (!item) {
              continue;
            }
            if (item.role === "header") {
              // Header-Stickies laufen separat unter "header"
              continue;
            }

            const areaName = item.regionTitle || "Ohne Area";
            if (!areasByName[areaName]) {
              areasByName[areaName] = {
                name: areaName,
                stickies: []
              };
            }

            const tags = Array.isArray(item.tags)
              ? item.tags
                  .map(function (t) { return t && t.title; })
                  .filter(function (title) { return !!title; })
              : [];

            const stickObj = {
              text: item.text,
              color: item.color || null,
              tags: tags,
              clusterName: item.clusterName || null,
              connectionsOut: buildConnectionsOut(item),
              connectionsIn: buildConnectionsIn(item)
            };

            areasByName[areaName].stickies.push(stickObj);
          }
        }

        const connectionsSummary = Array.isArray(one.connections)
          ? one.connections.map(function (c) {
              const fromItem = c.fromStickyId ? idToItem[c.fromStickyId] : null;
              const toItem = c.toStickyId ? idToItem[c.toStickyId] : null;

              const fromArea = fromItem
                ? (fromItem.regionTitle || (fromItem.role === "header" ? "Header" : null))
                : null;
              const toArea = toItem
                ? (toItem.regionTitle || (toItem.role === "header" ? "Header" : null))
                : null;

              return {
                connectorId: c.connectorId,
                fromText: fromItem ? fromItem.text : null,
                fromArea: fromArea,
                toText: toItem ? toItem.text : null,
                toArea: toArea
              };
            })
          : [];

        return {
          template: {
            name: one.template && one.template.name,
            headerSummary: one.template && one.template.headerSummary
          },
          header: header,
          areas: Object.keys(areasByName).map(function (key) {
            return areasByName[key];
          }),
          connections: connectionsSummary
        };
      }

      const templatesPayload = perTemplate.map(transformOne);

      return {
        templates: templatesPayload
      };
    }

    // --------------------------------------------------------------------
    // 3) Klassischer OpenAI-Call (Side-Panel)
    //    - ruft intern zuerst dtClassifyStickies({ silent: true }) auf
    // --------------------------------------------------------------------
    async function dtCallOpenAI() {
      await dtEnsureMiroReady();

      const apiKey  = document.getElementById("api-key").value.trim();
      const model   = document.getElementById("model").value;
      const userText = document.getElementById("user-text").value.trim();

      if (!apiKey) {
        log("Bitte OpenAI API Key eingeben.");
        return;
      }
      if (!userText) {
        log("Bitte eine Frage / Aufgabe im Textfeld eingeben.");
        return;
      }

      // Immer vor dem GPT-Call frisch klassifizieren (aktueller Zustand)
      const classification = await dtClassifyStickies({ silent: true });

      // Reduziertes, modellfreundliches JSON aus der Klassifikation bauen
      const promptPayload = classification
        ? dtBuildPromptPayloadFromClassification(classification)
        : null;

      const classificationPart = promptPayload
        ? "\n\nAktuelle Sticky-Notiz-Klassifikation (reduziertes JSON für das Sprachmodell):\n" +
          JSON.stringify(promptPayload, null, 2)
        : "\n\nHinweis: Es liegt noch keine Klassifikation vor (kein Template gesetzt " +
          "oder keine Stickies innerhalb der Templates).";

      const fullUserText = userText + classificationPart;

      const body = {
        model,
        input: [
          {
            role: "system",
            content: [
              {
                type: "input_text",
                text:
                  "Du bist ein Assistent, der Miro-Boards analysiert. " +
                  "Du bekommst Sticky-Notes als JSON und eine Nutzerfrage " +
                  "und sollst exakte Antworten liefern. " +
                  "Antworte standardmäßig auf Deutsch."
              }
            ]
          },
          {
            role: "user",
            content: [
              {
                type: "input_text",
                text: fullUserText
              }
            ]
          }
        ],
        max_output_tokens: 10000
      };

      try {
        log("Sende Anfrage an OpenAI (klassischer Call) ...");
        const res = await fetch("https://api.openai.com/v1/responses", {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + apiKey,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        });

        const text = await res.text();
        if (!res.ok) {
          log("Fehler bei OpenAI-Anfrage: " + res.status + " " + text);
          return;
        }

        const data = JSON.parse(text);
        const firstMessage = data.output && data.output[0];
        const contentArr = firstMessage && firstMessage.content;
        const textPart = contentArr && contentArr.find((c) => c.type === "output_text");
        const answer = textPart ? textPart.text : "(keine Antwort gefunden)";

        log("Antwort von OpenAI (klassischer Call):");
        log(answer);
      } catch (e) {
        log("Exception beim Aufruf der OpenAI API: " + e.message);
      }
    }

    // --------------------------------------------------------------------
    // 4) Change-Tracker für Instanzen
    // --------------------------------------------------------------------
    function dtComputeInstanceDiff(prevClassification, newClassification) {
      const diff = {
        created: [],
        deleted: [],
        updated: []
      };

      if (!newClassification || !Array.isArray(newClassification.items)) {
        if (prevClassification && Array.isArray(prevClassification.items)) {
          prevClassification.items.forEach(function (oldItem) {
            diff.deleted.push({
              stickyId: oldItem.stickyId,
              text: oldItem.text || "",
              regionId: oldItem.regionId || null,
              color: oldItem.color || null,
              clusterName: oldItem.clusterName || null
            });
          });
        }
        return diff;
      }

      const prevItemsById = {};
      if (prevClassification && Array.isArray(prevClassification.items)) {
        prevClassification.items.forEach(function (item) {
          if (item && item.stickyId) {
            prevItemsById[item.stickyId] = item;
          }
        });
      }

      const newItemsById = {};
      newClassification.items.forEach(function (item) {
        if (item && item.stickyId) {
          newItemsById[item.stickyId] = item;
        }
      });

      const prevIds = Object.keys(prevItemsById);
      const newIds = Object.keys(newItemsById);

      const prevIdSet = {};
      prevIds.forEach(function (id) { prevIdSet[id] = true; });

      const newIdSet = {};
      newIds.forEach(function (id) { newIdSet[id] = true; });

      // created
      newIds.forEach(function (id) {
        if (!prevIdSet[id]) {
          const it = newItemsById[id];
          diff.created.push({
            stickyId: it.stickyId,
            text: it.text || "",
            regionId: it.regionId || null,
            color: it.color || null,
            clusterName: it.clusterName || null
          });
        }
      });

      // deleted
      prevIds.forEach(function (id) {
        if (!newIdSet[id]) {
          const it = prevItemsById[id];
          diff.deleted.push({
            stickyId: it.stickyId,
            text: it.text || "",
            regionId: it.regionId || null,
            color: it.color || null,
            clusterName: it.clusterName || null
          });
        }
      });

      // updated (inhaltlich)
      function normalizeTags(tags) {
        if (!Array.isArray(tags)) {
          return "";
        }
        const titles = tags
          .map(function (t) { return t && t.title; })
          .filter(function (t) { return !!t; })
          .sort();
        return titles.join("|");
      }

      newIds.forEach(function (id) {
        const oldItem = prevItemsById[id];
        const newItem = newItemsById[id];
        if (!oldItem || !newItem) {
          return;
        }

        const oldSummary = {
          text: oldItem.text || "",
          regionId: oldItem.regionId || null,
          color: oldItem.color || null,
          clusterName: oldItem.clusterName || null,
          tags: normalizeTags(oldItem.tags)
        };

        const newSummary = {
          text: newItem.text || "",
          regionId: newItem.regionId || null,
          color: newItem.color || null,
          clusterName: newItem.clusterName || null,
          tags: normalizeTags(newItem.tags)
        };

        const isSame =
          oldSummary.text === newSummary.text &&
          oldSummary.regionId === newSummary.regionId &&
          oldSummary.color === newSummary.color &&
          oldSummary.clusterName === newSummary.clusterName &&
          oldSummary.tags === newSummary.tags;

        if (!isSame) {
          diff.updated.push({
            stickyId: newItem.stickyId,
            before: oldSummary,
            after: newSummary
          });
        }
      });

      return diff;
    }

    // --------------------------------------------------------------------
    // 5) Agent-Variante A (Headless) für eine Instanz
    //    - nutzt Board-Katalog + Instanz-JSON + Change-Tracker
    // --------------------------------------------------------------------
    async function dtGetInstanceStateForAgent(instance, options) {
      await dtEnsureMiroReady();

      if (!instance || !instance.imageId) {
        log("dtGetInstanceStateForAgent: Instanz hat kein imageId.");
        return null;
      }

      // Aktuelle Bild-Geometrie laden
      let imgArr = null;
      try {
        imgArr = await miro.board.get({ id: instance.imageId });
      } catch (e) {
        log("Fehler beim Laden des Template-Bildes der Instanz: " + e.message);
        return null;
      }
      const img = Array.isArray(imgArr) ? imgArr[0] : imgArr;
      if (!img) {
        log("Das Template-Bild der Instanz existiert nicht mehr auf dem Board.");
        return null;
      }

      instance.title = img.title || instance.title || "Datentreiber 3-Boxes";
      instance.lastGeometry = {
        x: img.x,
        y: img.y,
        width: img.width,
        height: img.height
      };

      let ctx = options && options.ctx;
      if (!ctx) {
        ctx = await dtGetBoardBaseContext();
      }

      const previousClassification = instance.lastClassification || null;

      const classification = dtClassifyStickiesForTemplate(
        {
          id: img.id,
          title: instance.title,
          x: img.x,
          y: img.y,
          width: img.width,
          height: img.height
        },
        ctx
      );

      const diff = dtComputeInstanceDiff(previousClassification, classification);

      const payload = dtBuildPromptPayloadFromClassification(classification);
      const stateJson = JSON.stringify(payload, null, 2);

      const prevStateJson = instance.lastStateJson;
      instance.lastClassification = classification;
      instance.lastStateJson = stateJson;
      instance.lastStickyCount = classification && classification.counts
        ? (classification.counts.total || 0)
        : (Array.isArray(classification.items) ? classification.items.length : 0);

      if (!prevStateJson || prevStateJson !== stateJson) {
        if (dtDiffHasChanges(diff)) {
          instance.lastChangedAt = new Date().toISOString();
        }
      }

      instance.lastDiff = diff;

      return {
        classification,
        promptPayload: payload,
        stateJson,
        diff
      };
    }

    function dtNormalizedToBoardCoords(templateGeometry, px, py) {
      const { x, y, width, height } = templateGeometry;
      const left = x - width / 2;
      const top = y - height / 2;
      const bx = left + px * width;
      const by = top + py * height;
      return { x: bx, y: by };
    }

    function dtAreaCenterNormalized(regionId) {
      const yMin = 0.20;
      const yMax = 0.95;
      const py = (yMin + yMax) / 2;

      if (regionId === "left") {
        return { px: 1 / 6, py };
      } else if (regionId === "middle") {
        return { px: 0.5, py };
      } else if (regionId === "right") {
        return { px: 5 / 6, py };
      }
      // Fallback: Mitte
      return { px: 0.5, py: 0.5 };
    }

    async function dtActionMoveSticky(templateGeometry, action) {
      const stickyId = action.stickyId;
      if (!stickyId) return;

      let targetPx = action.targetPx;
      let targetPy = action.targetPy;

      if (typeof targetPx !== "number" || typeof targetPy !== "number") {
        // Area-Name verwenden
        const region = dtAreaNameToRegion(action.targetArea);
        const center = dtAreaCenterNormalized(region ? region.id : null);
        targetPx = center.px;
        targetPy = center.py;
      }

      try {
        let arr = await miro.board.get({ id: stickyId });
        const sticky = Array.isArray(arr) ? arr[0] : arr;
        if (!sticky) {
          log("move_sticky: Sticky mit ID " + stickyId + " nicht gefunden.");
          return;
        }

        const coords = dtNormalizedToBoardCoords(templateGeometry, targetPx, targetPy);
        sticky.x = coords.x;
        sticky.y = coords.y;
        await sticky.sync();
      } catch (e) {
        log("Fehler bei move_sticky (" + stickyId + "): " + e.message);
      }
    }

    async function dtActionCreateSticky(templateGeometry, action) {
      const areaName = action.area;
      const text = action.text || "";
      const region = dtAreaNameToRegion(areaName);
      const center = dtAreaCenterNormalized(region ? region.id : null);
      const coords = dtNormalizedToBoardCoords(templateGeometry, center.px, center.py);

      try {
        await miro.board.createStickyNote({
          content: text || "(leer)",
          x: coords.x,
          y: coords.y
        });
      } catch (e) {
        log("Fehler bei create_sticky: " + e.message);
      }
    }

    async function dtActionDeleteSticky(action) {
      const stickyId = action.stickyId;
      if (!stickyId) return;
      try {
        const arr = await miro.board.get({ id: stickyId });
        const sticky = Array.isArray(arr) ? arr[0] : arr;
        if (!sticky) {
          log("delete_sticky: Sticky mit ID " + stickyId + " nicht gefunden.");
          return;
        }
        await miro.board.remove(sticky);
      } catch (e) {
        log("Fehler bei delete_sticky (" + stickyId + "): " + e.message);
      }
    }

    async function dtApplyCanvasActions(instanceId, actions) {
      if (!Array.isArray(actions) || !actions.length) {
        log("Keine Actions vom Agenten erhalten (actions-Array ist leer).");
        return;
      }

      const instance = dtInstancesById.get(instanceId);
      if (!instance) {
        log("dtApplyCanvasActions: Unbekannte Instanz-ID " + instanceId);
        return;
      }

      const geom = instance.lastGeometry;
      if (!geom) {
        log("dtApplyCanvasActions: Keine Geometrie für Instanz " + instanceId);
        return;
      }

      log("Wende " + actions.length + " Action(s) auf Instanz " + instanceId + " an ...");

      for (const action of actions) {
        if (!action || !action.type) continue;
        const type = action.type;
        if (type === "move_sticky") {
          await dtActionMoveSticky(geom, action);
        } else if (type === "create_sticky") {
          await dtActionCreateSticky(geom, action);
        } else if (type === "delete_sticky") {
          await dtActionDeleteSticky(action);
        } else {
          log("Unbekannter Action-Typ vom Agenten: " + type);
        }
      }
    }

    async function dtRunAgentForInstance(instanceId, options) {
      await dtEnsureMiroReady();
      await dtScanTemplateInstances();

      const apiKey  = document.getElementById("api-key").value.trim();
      const model   = document.getElementById("model").value;
      const userText = (options && options.userText) || dtGetCurrentUserQuestion();

      if (!apiKey) {
        log("Bitte OpenAI API Key eingeben (für den Agenten-Run).");
        return;
      }

      const instance = dtInstancesById.get(instanceId);
      if (!instance) {
        log("Unbekannte Canvas-Instanz: " + instanceId);
        return;
      }

      const promptCfg = DT_PROMPT_CATALOG[instance.canvasTypeId] || DT_PROMPT_CATALOG[TEMPLATE_ID];
      const systemPrompt = promptCfg.system;

      log("Starte Agent (Variante A, headless) für Instanz " + instanceId + " ...");

      // Alle Instanzen frisch scannen, um den Change-Tracker zu aktualisieren
      const ctx = await dtGetBoardBaseContext();
      const stateById = {};

      const allInstances = [];
      dtInstancesById.forEach(function (inst) {
        allInstances.push(inst);
      });

      for (const inst of allInstances) {
        const st = await dtGetInstanceStateForAgent(inst, { ctx: ctx });
        if (st) {
          stateById[inst.instanceId] = st;
        }
      }

      const state = stateById[instanceId];
      if (!state || !state.promptPayload) {
        log("Konnte Instanzzustand für den Agenten nicht ermitteln.");
        return;
      }

      const boardCatalog = dtBuildBoardCatalogSummary(instanceId);

      const userPayload = {
        userQuestion: userText,
        activeInstanceId: instanceId,
        boardCatalog: boardCatalog,
        activeCanvasState: state.promptPayload,
        activeInstanceChangesSinceLastAgent: state.diff || null,
        hint: "boardCatalog = Kurzüberblick über alle Instanzen (inkl. Changes seit letztem Agent-Run), activeCanvasState = detaillierte Stickies/Areas/Verbindungen nur für die aktive Instanz."
      };

      const body = {
        model,
        input: [
          {
            role: "system",
            content: [
              {
                type: "input_text",
                text: systemPrompt
              }
            ]
          },
          {
            role: "user",
            content: [
              {
                type: "input_text",
                text: JSON.stringify(userPayload, null, 2)
              }
            ]
          }
        ],
        max_output_tokens: 4000
      };

      try {
        log("Sende Agent-Request an OpenAI (Instanz " + instanceId + ") ...");
        const res = await fetch("https://api.openai.com/v1/responses", {
          method: "POST",
          headers: {
            "Authorization": "Bearer " + apiKey,
            "Content-Type": "application/json"
          },
          body: JSON.stringify(body)
        });

        const text = await res.text();
        if (!res.ok) {
          log("Fehler bei OpenAI-Agent-Anfrage: " + res.status + " " + text);
          return;
        }

        const data = JSON.parse(text);
        const firstMessage = data.output && data.output[0];
        const contentArr = firstMessage && firstMessage.content;
        const textPart = contentArr && contentArr.find((c) => c.type === "output_text");
        const answer = textPart ? textPart.text : null;

        if (!answer) {
          log("Agent: Keine output_text-Antwort gefunden.");
          return;
        }

        let agentObj = null;
        try {
          agentObj = JSON.parse(answer);
        } catch (e) {
          log("Agent-Antwort ist kein valides JSON. Rohantwort:");
          log(answer);
          return;
        }

        log("Agent-Analyse (analysis):");
        log(agentObj.analysis || "(keine analysis)");

        if (Array.isArray(agentObj.actions) && agentObj.actions.length) {
          await dtApplyCanvasActions(instanceId, agentObj.actions);
        } else {
          log("Agent lieferte keine Actions (actions-Array ist leer).");
        }
      } catch (e) {
        log("Exception beim Agent-Run: " + e.message);
      }
    }

    // --------------------------------------------------------------------
    // Exporte ins window (für inline-onclick)
    // --------------------------------------------------------------------
    window.dtInsertTemplateImage      = dtInsertTemplateImage;
    window.dtSetTemplateFromSelection = dtSetTemplateFromSelection;
    window.dtClassifyStickies         = dtClassifyStickies;
    window.dtCallOpenAI               = dtCallOpenAI;
    window.dtClusterSelection         = dtClusterSelection;
    // Agent-Funktion exportieren (kann bei Bedarf auch aus der Konsole getestet werden)
    window.dtRunAgentForInstance      = dtRunAgentForInstance;

  </script>
</body>
</html>
