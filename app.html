<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Datentreiber – Template Mapper</title>
  <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:16px; }
    h1 { font-size: 16px; margin: 0 0 8px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .col { display:flex; flex-direction:column; gap:6px; }
    input[type="text"], select, textarea { padding:8px; border-radius:8px; border:1px solid #ccc; min-width: 260px; }
    button { padding:8px 12px; border:1px solid #ccc; border-radius:8px; cursor:pointer; }
    textarea { width: 100%; min-height: 100px; }
    .muted { color:#666 }
    .card { border:1px solid #ddd; border-radius:12px; padding:12px; }
    .thumb { width: 220px; height:auto; border-radius:8px; border:1px solid #ddd; }
    .grid { display:grid; grid-template-columns: auto 1fr; gap: 12px; align-items: start; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; white-space:pre-wrap; }
    .ok { color: #0a7f2e; }
    .err { color: #b00020; }
    .spacer { height: 8px; }
    #app[hidden] { display:none; }
  </style>
</head>
<body>
  <div id="app" hidden>
    <h1>Datentreiber – Template Mapper</h1>
    <div class="muted" id="loadedAt"></div>

    <!-- 1) OpenAI Konfiguration -->
    <div class="card">
      <div class="row">
        <div class="col">
          <label for="key">OpenAI API Key (wird nur im Speicher gehalten)</label>
          <input id="key" type="text" placeholder="sk-..." />
        </div>
        <div class="col">
          <label for="model">Modell</label>
          <select id="model">
            <option value="gpt-4o-mini" selected>gpt-4o-mini</option>
            <option value="gpt-4.1-mini">gpt-4.1-mini</option>
            <option value="gpt-4.1">gpt-4.1</option>
            <option value="gpt-5">gpt-5</option>
          </select>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="col">
        <label for="prompt">Prompt (optional, wird zusammen mit den Sticky-Daten gesendet)</label>
        <textarea id="prompt" rows="3" placeholder="Analysiere die Stickies je Bereich ..."></textarea>
      </div>
    </div>

    <div class="spacer"></div>

    <!-- 2) Template-Auswahl -->
    <div class="card">
      <strong>Template auswählen und einfügen</strong>
      <div class="spacer"></div>
      <div class="grid">
        <img id="tpl-thumb" class="thumb"
          src="https://www.datentreiber.com/wp-content/uploads/2024/12/Datentreiber_EN_3-Boxes_v1-1_20240610.png"
          alt="Datentreiber 3-Boxes" />
        <div class="col">
          <div class="muted">Datentreiber 3-Boxes (Header, Footer, Title, 3 Boxes)</div>
          <div class="row">
            <button id="btn-insert">Template als Frame+Image einfügen</button>
            <button id="btn-zoom">Zum zuletzt eingefügten Template zoomen</button>
          </div>
          <div class="muted" id="insertStatus"></div>
        </div>
      </div>
    </div>

    <div class="spacer"></div>

    <!-- 3) Analyse/Senden -->
    <div class="card">
      <strong>Analyse & Senden an OpenAI</strong>
      <div class="spacer"></div>
      <div class="row">
        <button id="btn-scan">Stickies im Frame klassifizieren</button>
        <button id="btn-send">Stickies + Bereiche an OpenAI senden</button>
      </div>
      <div class="spacer"></div>
      <div id="scanOut" class="mono"></div>
      <div class="spacer"></div>
      <div id="llmOut" class="mono"></div>
    </div>
  </div>

  <script>
    // ------------------------------
    // KONSTANTEN & TEMPLATE-DATEN
    // ------------------------------
    const TEMPLATE = {
      id: "datentreiber-3boxes",
      name: "Datentreiber 3-Boxes v1-1 (20240610)",
      imageUrl: "https://www.datentreiber.com/wp-content/uploads/2024/12/Datentreiber_EN_3-Boxes_v1-1_20240610.png",
      areasPx: [
        { id: "1a_header", title: "Header", shape: "rect", coords: [157, 8, 705, 80] },
        { id: "1b_footer", title: "Footer", shape: "rect", coords: [17, 676, 562, 706] },
        { id: "2_title",  title: "Title",  shape: "rect", coords: [123, 83, 874, 148] },
        { id: "3_boxes",  title: "3 Boxes", shape: "poly",
          coords: [21,109, 119,110, 119,150, 878,150, 877,109, 979,109, 978,639, 22,640] }
      ]
    };
    const META_KEY = "dt.template";   // am IMAGE gespeichert
    let lastTemplate = null;          // { frameId, imageId }

    // ------------------------------
    // GEOMETRIE-UTILS (GLOBAL!)
    // ------------------------------
    function rectContainsNorm(px, py, [x1,y1,x2,y2]) {
      const left = Math.min(x1,x2), right = Math.max(x1,x2);
      const top  = Math.min(y1,y2), bottom= Math.max(y1,y2);
      return px >= left && px <= right && py >= top && py <= bottom;
    }
    function polyContainsNorm(px, py, coords) {
      let inside = false;
      for (let i=0, j=coords.length-2; i<coords.length; i+=2) {
        const xi = coords[i], yi = coords[i+1];
        const xj = coords[j], yj = coords[j+1];
        const intersect = ((yi > py) !== (yj > py)) &&
                          (px < (xj - xi) * (py - yi) / (yj - yi + 1e-12) + xi);
        if (intersect) inside = !inside;
        j = i;
      }
      return inside;
    }
    function pxAreasToNormalized(areasPx, natW, natH) {
      return areasPx.map(a => {
        if (a.shape === "rect") {
          const [x1,y1,x2,y2] = a.coords;
          return { ...a, coords: [x1/natW, y1/natH, x2/natW, y2/natH] };
        } else if (a.shape === "poly") {
          const out = [];
          for (let i=0;i<a.coords.length;i+=2) out.push(a.coords[i]/natW, a.coords[i+1]/natH);
          return { ...a, coords: out };
        } else {
          return a;
        }
      });
    }

    async function getParentFrameOf(item) {
      const frames = await miro.board.get({ type: 'frame' });
      for (const f of frames) {
        if (f.childrenIds && f.childrenIds.includes(item.id)) return f;
      }
      return null;
    }
    function frameTopLeft(frame) {
      return { x: frame.x - frame.width/2, y: frame.y - frame.height/2 };
    }
    async function getGlobalCenter(item) {
      const parent = await getParentFrameOf(item);
      if (!parent) return { x: item.x, y: item.y }; // bereits global
      const tl = frameTopLeft(parent);
      return { x: tl.x + item.x, y: tl.y + item.y };
    }
    async function centerToImageNormGlobal(sticky, image) {
      const s = await getGlobalCenter(sticky);
      const imgC = await getGlobalCenter(image);
      const imgLeft = imgC.x - image.width/2;
      const imgTop  = imgC.y - image.height/2;
      const px = (s.x - imgLeft) / image.width;
      const py = (s.y - imgTop ) / image.height;
      return { px, py };
    }

    // ------------------------------
    // TEMPLATE INS BOARD SETZEN
    // ------------------------------
    async function insertTemplate() {
      const status = document.getElementById('insertStatus');
      status.textContent = "Lade Bildgröße ...";
      const nat = await loadNaturalSize(TEMPLATE.imageUrl);

      status.textContent = "Erzeuge Frame und Bild ...";
      const vp = await miro.board.viewport.get();
      const frameWidth = Math.min(1200, Math.max(800, vp.width * 0.8));
      const frameHeight = frameWidth * (nat.h / nat.w) + 80;

      const frame = await miro.board.createFrame({
        title: TEMPLATE.name,
        width: frameWidth,
        height: frameHeight,
        x: 0, y: 0,
        style: { fillColor: "#ffffff" }
      });

      const image = await miro.board.createImage({
        url: TEMPLATE.imageUrl,
        x: frame.x,
        y: frame.y + 20,
        width: frameWidth - 40
      });

      await frame.add(image);

      const areasNorm = pxAreasToNormalized(TEMPLATE.areasPx, nat.w, nat.h);
      await image.setMetadata(META_KEY, {
        templateId: TEMPLATE.id,
        templateName: TEMPLATE.name,
        natural: nat,
        areas: areasNorm,
      });

      lastTemplate = { frameId: frame.id, imageId: image.id };
      status.innerHTML = `<span class="ok">Template eingefügt ✔︎</span>`;
      await miro.board.viewport.zoomTo(frame);
    }

    async function loadNaturalSize(url) {
      return new Promise((res, rej) => {
        const img = new Image();
        img.onload = () => res({ w: img.naturalWidth, h: img.naturalHeight });
        img.onerror = rej;
        img.src = url + (url.includes("?") ? "&" : "?") + "cachebust=" + Date.now();
      });
    }

    // ------------------------------
    // TEMPLATE-OBJEKTE FINDEN
    // ------------------------------
    async function findLastTemplate() {
      if (lastTemplate) {
        const img = await miro.board.getById(lastTemplate.imageId);
        const frm = await miro.board.getById(lastTemplate.frameId);
        if (img && frm) return { image: img, frame: frm };
      }
      const images = await miro.board.get({ type: 'image' });
      for (let i=images.length-1; i>=0; i--) {
        const meta = await images[i].getMetadata(META_KEY);
        if (meta && meta.templateId === TEMPLATE.id) {
          const parentFrame = await getParentFrameOf(images[i]);
          if (parentFrame) {
            lastTemplate = { imageId: images[i].id, frameId: parentFrame.id };
            return { image: images[i], frame: parentFrame };
          }
        }
      }
      return null;
    }

    // ------------------------------
    // STICKIES KLASSIFIZIEREN (GLOBAL!)
    // ------------------------------
    async function classifyStickiesInFrame() {
      const tpl = await findLastTemplate();
      if (!tpl) throw new Error("Kein Template gefunden. Bitte zuerst einfügen.");
      const { image, frame } = tpl;

      const meta = await image.getMetadata(META_KEY);
      if (!meta || !meta.areas || !meta.natural) {
        throw new Error("Template-Metadaten fehlen oder sind unvollständig.");
      }

      // Wir betrachten ALLE Stickies auf dem Board (nicht nur Frame-Kinder),
      // filtern aber optional per grober Bounding-Box des Bildes.
      const allStickies = await miro.board.get({ type: 'sticky_note' });

      const imgCenter = await getGlobalCenter(image);
      const imgLeft   = imgCenter.x - image.width/2;
      const imgTop    = imgCenter.y - image.height/2;
      const imgRight  = imgLeft + image.width;
      const imgBottom = imgTop  + image.height;

      const candidates = allStickies.filter(async s => {
        const c = await getGlobalCenter(s);
        return c.x >= imgLeft && c.x <= imgRight && c.y >= imgTop && c.y <= imgBottom;
      });

      // candidates ist ein Array von Promises (wegen async filter); richtig lösen:
      const candWithCenter = [];
      for (const s of allStickies) {
        const c = await getGlobalCenter(s);
        if (c.x >= imgLeft && c.x <= imgRight && c.y >= imgTop && c.y <= imgBottom) {
          candWithCenter.push({ s, c });
        }
      }

      const results = [];
      for (const { s } of candWithCenter) {
        const text = stripHtml(s.content || "");
        const { px, py } = await centerToImageNormGlobal(s, image);

        let hit = null;
        for (const area of meta.areas) {
          if (area.shape === "rect") {
            if (rectContainsNorm(px, py, area.coords)) { hit = area; break; }
          } else if (area.shape === "poly") {
            if (polyContainsNorm(px, py, area.coords)) { hit = area; break; }
          }
        }
        results.push({
          stickyId: s.id,
          regionId: hit ? hit.id : null,
          regionTitle: hit ? hit.title : null,
          text
        });
      }

      return {
        template: { id: meta.templateId, name: meta.templateName },
        counts: {
          total: results.length,
          byRegion: Object.fromEntries(
            Object.entries(groupBy(results.filter(r=>r.regionId), r=> r.regionId))
                  .map(([k, arr]) => [k, arr.length])
          )
        },
        items: results
      };
    }

    function stripHtml(html) {
      const tmp = document.createElement('div');
      tmp.innerHTML = html;
      return tmp.textContent || tmp.innerText || "";
    }
    function groupBy(arr, fn) {
      return arr.reduce((acc, cur) => {
        const k = fn(cur);
        (acc[k] ||= []).push(cur);
        return acc;
      }, {});
    }

    // ------------------------------
    // OPENAI – Responses API
    // ------------------------------
    async function sendToOpenAI({ apiKey, model, userPrompt, payload }) {
      if (!apiKey || !apiKey.trim()) throw new Error("OpenAI API Key fehlt.");
      const body = {
        model,
        input: [
          {
            type: "message",
            role: "user",
            content: [
              { type: "input_text",
                text:
`Du bist ein Assistent in Miro. Analysiere die Sticky Notes je Bildbereich.
Eingabe ist JSON (template, items[] mit regionId/Title und text). Antworte kompakt:
- Zusammenfassung je Bereich (Bullets)
- Auffälligkeiten / Lücken
- Max. 200 Wörter.` },
              { type: "input_text", text: "User-Prompt: " + (userPrompt || "(leer)") },
              { type: "input_text", text: "Daten:\n" + JSON.stringify(payload, null, 2) }
            ]
          }
        ],
        max_output_tokens: 700
      };

      const resp = await fetch("https://api.openai.com/v1/responses", {
        method: "POST",
        headers: {
          "Authorization": "Bearer " + apiKey,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      });
      const data = await resp.json();
      if (!resp.ok) throw new Error("OpenAI request failed: " + resp.status + " " + JSON.stringify(data, null, 2));

      const msg = data?.output?.[0];
      let text = "";
      if (msg?.content) {
        const t = msg.content.find(c => c.type === "output_text");
        text = t?.text || "";
      }
      return text || JSON.stringify(data, null, 2);
    }

    // ------------------------------
    // PANEL BOOTSTRAP
    // ------------------------------
    (async function boot() {
      const url = new URL(window.location.href);
      const isPanel = url.searchParams.get('panel') === '1';

      if (!isPanel) {
        miro.board.ui.on('icon:click', async () => {
          const panelUrl = sameFileWithParam(window.location.href, "panel", "1");
          await miro.board.ui.openPanel({ url: panelUrl });
        });
        const panelUrl = sameFileWithParam(window.location.href, "panel", "1");
        await miro.board.ui.openPanel({ url: panelUrl });
        return;
      }

      document.getElementById('app').hidden = false;
      document.getElementById('loadedAt').textContent =
        "Panel geladen: " + new Date().toLocaleTimeString();

      document.getElementById('btn-insert').onclick = async () => {
        try { await insertTemplate(); }
        catch (e) { setStatus('insertStatus', e); }
      };
      document.getElementById('btn-zoom').onclick = async () => {
        const tpl = await findLastTemplate();
        if (tpl?.frame) await miro.board.viewport.zoomTo(tpl.frame);
      };

      document.getElementById('btn-scan').onclick = async () => {
        const out = document.getElementById('scanOut');
        out.textContent = "Scanne ...";
        try {
          const res = await classifyStickiesInFrame();
          out.textContent = JSON.stringify(res, null, 2);
        } catch (e) {
          out.innerHTML = '<span class="err">' + e.message + '</span>';
        }
      };

      document.getElementById('btn-send').onclick = async () => {
        const out = document.getElementById('llmOut');
        out.textContent = "Sende an OpenAI ...";
        try {
          const payload = await classifyStickiesInFrame();
          const text = await sendToOpenAI({
            apiKey: document.getElementById('key').value,
            model: document.getElementById('model').value,
            userPrompt: document.getElementById('prompt').value,
            payload
          });
          out.innerHTML = '<span class="ok">Antwort:</span>\n' + text;
        } catch (e) {
          out.innerHTML = '<span class="err">' + e.message + '</span>';
        }
      };
    })();

    function sameFileWithParam(href, k, v) {
      const u = new URL(href, location.origin);
      u.searchParams.set(k, v);
      u.searchParams.delete('_miro'); u.searchParams.delete('_sdk');
      return u.pathname + "?" + u.searchParams.toString();
    }
    function setStatus(id, err) {
      document.getElementById(id).innerHTML =
        '<span class="err">' + (err?.message || err) + '</span>';
    }
  </script>
</body>
</html>
