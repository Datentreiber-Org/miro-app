<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Miro Template Classifier</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; line-height: 1.35; }
    .row { display: flex; gap: 8px; align-items: center; margin-bottom: 10px; flex-wrap: wrap; }
    label { font-weight: 600; }
    select, button { padding: 6px 10px; border: 1px solid #ccc; border-radius: 8px; }
    button { cursor: pointer; }
    .hint { color: #666; font-size: 12px; }
    .area-badge { display: inline-block; padding: 2px 6px; border-radius: 999px; font-size: 12px; background:#efefef; margin-right:6px; }
    .card { border: 1px solid #eee; border-radius: 14px; padding: 12px; margin: 12px 0; }
    .muted { color: #666; }
    .ok { color: #047857; font-weight: 600; }
    .warn { color: #b45309; font-weight: 600; }
    code { word-break: break-all; }
  </style>
  <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
</head>
<body>
  <h1>Template Classifier</h1>
  <p class="muted">Platziere ein Template-Bild und klassifiziere selektierte Stickies per Image-Map-Zonen.</p>

  <div class="card">
    <div class="row">
      <label for="tpl">Template:</label>
      <select id="tpl"></select>
      <button id="placeTemplate">Template platzieren</button>
    </div>
    <div class="row">
      <span>Aktuelles Template-Image:</span>
      <span id="imgStatus" class="warn">kein Bild platziert</span>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <button id="classify">Selektierte Stickies klassifizieren</button>
      <button id="clearPrefix">Area-Prefix aus Selektion entfernen</button>
    </div>
    <div class="hint">Tipp: Mehrere Stickies im Board markieren (Shift/Drag), dann hier klicken.</div>
  </div>

  <div class="card">
    <h3>Aktuelles Template</h3>
    <div>Bild: <code id="tplImgUrl"></code></div>
    <div>Base-Size (für px-Koordinaten): <span id="tplBaseSize"></span></div>
    <div id="areas"></div>
  </div>

  <script>
    // -----------------------------------------
    // TEMPLATES
    // - Unterstützt px- oder UV-Koordinaten:
    //   * rectPx: [x1,y1,x2,y2]  (Pixel, bezogen auf baseWidth/baseHeight)
    //   * polyPx: [[x,y], ...]   (Pixel, bezogen auf baseWidth/baseHeight)
    //   * rect:   [u1,v1,u2,v2]  (normalisiert 0..1)
    //   * poly:   [[u,v], ...]   (normalisiert 0..1)
    // -----------------------------------------
    const TEMPLATES = [
      {
        id: 'dt-3boxes',
        name: 'Datentreiber · 3 Boxes',
        imageUrl: 'https://www.datentreiber.com/wp-content/uploads/2024/12/Datentreiber_EN_3-Boxes_v1-1_20240610.png',
        // Die Image-Map-Koordinaten, die du geliefert hast, gehen bis ~979×640.
        // Wir definieren ein "Base"-Koordinatensystem 1000×640 px, damit deine Werte unverändert passen.
        baseWidth: 1000,
        baseHeight: 640,
        areas: [
          // Aus deiner Image-Map:
          // <area alt="1a_header" coords="157,8,705,80" shape="rect">
          { id: '1a_header', label: 'Header', type: 'rectPx', rectPx: [157, 8, 705, 80] },

          // <area alt="1b_footer" coords="17,676,562,706" shape="rect">
          // Achtung: y=676..706 liegt knapp unterhalb 640; wir clampen außerhalb automatisch auf [0, baseHeight].
          { id: '1b_footer', label: 'Footer', type: 'rectPx', rectPx: [17, 606, 562, 640] },

          // <area alt="2_title" coords="123,83,874,148" shape="rect">
          { id: '2_title', label: 'Title', type: 'rectPx', rectPx: [123, 83, 874, 148] },

          // <area alt="3_boxes" coords="21,109,119,110,119,150,878,150,877,109,979,109,978,639,22,640" shape="poly">
          { id: '3_boxes', label: 'Boxes', type: 'polyPx', polyPx: [
            [21,109],[119,110],[119,150],[878,150],[877,109],[979,109],[978,639],[22,640]
          ]},
        ],
      },
      // Du kannst hier weitere Templates ergänzen …
    ];

    // -----------------------------------------
    // STATE & UI
    // -----------------------------------------
    let currentTemplate = null;
    let placedImage = null; // {id,x,y,width,height}

    const elTpl = document.getElementById('tpl');
    const elPlace = document.getElementById('placeTemplate');
    const elClassify = document.getElementById('classify');
    const elClear = document.getElementById('clearPrefix');
    const elImgStatus = document.getElementById('imgStatus');
    const elTplImgUrl = document.getElementById('tplImgUrl');
    const elTplBaseSize = document.getElementById('tplBaseSize');
    const elAreas = document.getElementById('areas');

    function fillTemplateList() {
      elTpl.innerHTML = '';
      TEMPLATES.forEach(t => {
        const opt = document.createElement('option');
        opt.value = t.id;
        opt.textContent = t.name;
        elTpl.appendChild(opt);
      });
      currentTemplate = TEMPLATES[0];
      updateTemplateInfo();
    }

    function updateTemplateInfo() {
      if (!currentTemplate) return;
      elTplImgUrl.textContent = currentTemplate.imageUrl;
      elTplBaseSize.textContent = `${currentTemplate.baseWidth} × ${currentTemplate.baseHeight}px`;
      elAreas.innerHTML = '';
      currentTemplate.areas.forEach(a => {
        const s = document.createElement('span');
        s.className = 'area-badge';
        s.textContent = `${a.id}: ${a.label}`;
        elAreas.appendChild(s);
      });
    }

    elTpl.addEventListener('change', () => {
      const id = elTpl.value;
      currentTemplate = TEMPLATES.find(t => t.id === id) || null;
      updateTemplateInfo();
    });

    // -----------------------------------------
    // TEMPLATE PLATZIEREN
    // -----------------------------------------
    elPlace.addEventListener('click', async () => {
      if (!currentTemplate) return;

      const vp = await miro.board.viewport.getViewport(); // {x,y,width,height,zoom}
      const targetWidth = Math.min(1800, vp.width * 0.8);
      const scale = targetWidth / currentTemplate.baseWidth;
      const targetHeight = currentTemplate.baseHeight * scale;

      const centerX = vp.x + vp.width / 2;
      const centerY = vp.y + vp.height / 2;

      const img = await miro.board.createImage({
        x: centerX - targetWidth / 2,
        y: centerY - targetHeight / 2,
        width: targetWidth,
        height: targetHeight,
        url: currentTemplate.imageUrl,
      });

      placedImage = { id: img.id, x: img.x, y: img.y, width: img.width, height: img.height };
      elImgStatus.textContent = `Image #${img.id} platziert (${Math.round(img.width)}×${Math.round(img.height)})`;
      elImgStatus.className = 'ok';
      await miro.board.viewport.zoomTo(img);
    });

    // -----------------------------------------
    // KLASSIFIZIEREN & PREFIX PFLEGEN
    // -----------------------------------------
    elClassify.addEventListener('click', async () => {
      if (!currentTemplate || !placedImage) {
        alert('Bitte zuerst ein Template platzieren.');
        return;
      }
      const selection = await miro.board.getSelection();
      const stickies = selection.filter(it => it.type === 'sticky_note');
      if (!stickies.length) { alert('Bitte zuerst 1+ Stickies selektieren.'); return; }

      const res = [];
      for (const s of stickies) {
        const {u, v} = boardXYtoUV(s.x, s.y, placedImage);
        const area = findAreaForUV(u, v, currentTemplate);
        if (area) {
          const newContent = upsertAreaPrefix(s.content || '', area.label);
          await miro.board.update({ id: s.id, content: newContent });
          res.push({ id: s.id, ok: true, area: area.label });
        } else {
          res.push({ id: s.id, ok: false });
        }
      }
      const mapped = res.filter(r => r.ok).length;
      const missed = res.length - mapped;
      alert(`Klassifiziert: ${mapped}  ·  Ohne Treffer: ${missed}`);
    });

    elClear.addEventListener('click', async () => {
      const selection = await miro.board.getSelection();
      const stickies = selection.filter(it => it.type === 'sticky_note');
      if (!stickies.length) { alert('Bitte zuerst Stickies selektieren.'); return; }
      for (const s of stickies) {
        const cleared = removeAreaPrefix(s.content || '');
        await miro.board.update({ id: s.id, content: cleared });
      }
      alert('Area-Prefix entfernt.');
    });

    // -----------------------------------------
    // GEOMETRIE/TESTS
    // -----------------------------------------
    function boardXYtoUV(x, y, placed) {
      return { u: (x - placed.x) / placed.width, v: (y - placed.y) / placed.height };
    }

    function pxRectToUVRect(rectPx, tpl) {
      const [x1,y1,x2,y2] = rectPx;
      const u1 = clamp(x1 / tpl.baseWidth, 0, 1);
      const v1 = clamp(y1 / tpl.baseHeight, 0, 1);
      const u2 = clamp(x2 / tpl.baseWidth, 0, 1);
      const v2 = clamp(y2 / tpl.baseHeight, 0, 1);
      return [u1,v1,u2,v2];
    }

    function pxPolyToUVPoly(polyPx, tpl) {
      return polyPx.map(([x,y]) => [ clamp(x / tpl.baseWidth, 0, 1), clamp(y / tpl.baseHeight, 0, 1) ]);
    }

    function findAreaForUV(u, v, tpl) {
      if (u < 0 || v < 0 || u > 1 || v > 1) return null;

      for (const a of tpl.areas) {
        if (a.type === 'rect') {
          const [u1,v1,u2,v2] = a.rect;
          if (u>=u1 && u<=u2 && v>=v1 && v<=v2) return a;
        } else if (a.type === 'rectPx') {
          const [u1,v1,u2,v2] = pxRectToUVRect(a.rectPx, tpl);
          if (u>=u1 && u<=u2 && v>=v1 && v<=v2) return a;
        } else if (a.type === 'poly') {
          if (pointInPolygon(u, v, a.poly)) return a;
        } else if (a.type === 'polyPx') {
          const poly = pxPolyToUVPoly(a.polyPx, tpl);
          if (pointInPolygon(u, v, poly)) return a;
        }
      }
      return null;
    }

    function pointInPolygon(u, v, poly) {
      let inside = false;
      for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        const [xi, yi] = poly[i], [xj, yj] = poly[j];
        const intersect = ((yi > v) !== (yj > v)) && (u < (xj - xi) * (v - yi) / ((yj - yi) || 1e-12) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function upsertAreaPrefix(html, label) {
      const text = stripHtml(html);
      const without = text.replace(/^\[Area:[^\]]+\]\s*/i, '');
      const withPrefix = `[Area: ${label}] ${without}`;
      return `<p>${escapeHtml(withPrefix)}</p>`;
    }
    function removeAreaPrefix(html) {
      const text = stripHtml(html);
      const without = text.replace(/^\[Area:[^\]]+\]\s*/i, '');
      return `<p>${escapeHtml(without)}</p>`;
    }
    function stripHtml(s) {
      const tmp = document.createElement('div'); tmp.innerHTML = s || '';
      return (tmp.textContent || '').trim();
    }
    function escapeHtml(s) {
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[c]));
    }

    // -----------------------------------------
    // STARTUP
    // -----------------------------------------
    function initUI(){ fillTemplateList(); elImgStatus.textContent='kein Bild platziert'; elImgStatus.className='warn'; }
    miro.board.ui.on('icon:click', () => { /* optional */ });
    initUI();
  </script>
</body>
</html>
