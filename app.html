<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Datentreiber – Template Mapper & GPT</title>
  <script src="https://miro.com/app/static/sdk/v2/miro.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 13px;
      color: #111827;
      background: #f9fafb;
    }
    #app {
      padding: 12px;
      width: 100%;
      max-width: 420px;
    }
    h1 {
      font-size: 16px;
      margin: 0 0 8px;
    }
    h2 {
      font-size: 14px;
      margin: 16px 0 8px;
    }
    .section {
      background: #ffffff;
      border-radius: 8px;
      padding: 10px 10px 12px;
      margin-bottom: 10px;
      border: 1px solid #e5e7eb;
    }
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
    }
    input[type="text"],
    input[type="password"],
    select,
    textarea {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      font-size: 12px;
      font-family: inherit;
    }
    textarea {
      min-height: 60px;
      resize: vertical;
    }
    button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      background: #111827;
      color: white;
      font-size: 12px;
      cursor: pointer;
      margin-right: 6px;
      margin-top: 4px;
    }
    button.secondary {
      background: #ffffff;
      color: #111827;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .muted {
      color: #6b7280;
      font-size: 11px;
    }
    .row {
      display: flex;
      gap: 6px;
      margin-bottom: 6px;
    }
    .row > div {
      flex: 1;
    }
    pre {
      font-size: 11px;
      background: #0b1020;
      color: #e5e7eb;
      padding: 8px;
      border-radius: 6px;
      max-height: 220px;
      overflow: auto;
      margin-top: 6px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      padding: 2px 6px;
      border-radius: 999px;
      background: #eef2ff;
      color: #3730a3;
      font-size: 10px;
      font-weight: 600;
      margin-left: 4px;
    }
  </style>
</head>
<body>
  <div id="app">
    <h1>Datentreiber – Template Mapper & GPT</h1>
    <div class="muted" id="status-line">Panel lädt…</div>

    <!-- OpenAI / GPT Section -->
    <div class="section">
      <h2>1) GPT-Chat <span class="badge">OpenAI</span></h2>
      <label>
        OpenAI API Key (nur für Tests, bleibt im Browser)
        <input type="password" id="openai-key" placeholder="sk-...">
      </label>
      <div class="row">
        <div>
          <label>Modell</label>
          <select id="openai-model">
            <option value="gpt-4.1-mini">gpt-4.1-mini</option>
            <option value="gpt-4.1">gpt-4.1</option>
            <option value="o3-mini">o3-mini</option>
          </select>
        </div>
        <div>
          <label>Max. Tokens (Antwort)</label>
          <input type="text" id="openai-max-tokens" value="512">
        </div>
      </div>
      <label>
        Deine Frage an GPT
        <textarea id="openai-user-message" placeholder="Frag GPT etwas zu den Stickies oder allgemein…"></textarea>
      </label>
      <button id="btn-openai-send">An GPT senden (ohne Stickies)</button>
      <button id="btn-openai-send-with-stickies" class="secondary">
        Stickies klassifizieren & an GPT senden
      </button>
      <pre id="openai-output" class="muted">// GPT-Antwort erscheint hier…</pre>
    </div>

    <!-- Template / Sticky Mapping Section -->
    <div class="section">
      <h2>2) Template Mapper <span class="badge">3 Boxes</span></h2>
      <div class="muted" style="margin-bottom:6px;">
        Template-Bild: „Datentreiber 3-Boxes v1-1 (20240610)“  
        PNG wird als <strong>Image</strong> eingefügt; Stickies werden relativ zu diesem Bild vermessen.
      </div>

      <button id="btn-insert-template">Template einfügen</button>
      <button id="btn-list-templates" class="secondary">Vorhandene Templates auflisten</button>

      <div class="row" style="margin-top:6px;">
        <div>
          <label>Template-Image auf dem Board</label>
          <select id="template-select"></select>
        </div>
      </div>

      <button id="btn-zoom-template" class="secondary">Zum Template zoomen</button>
      <button id="btn-toggle-overlay" class="secondary">Areas einblenden</button>
      <button id="btn-classify-stickies">Nur Stickies klassifizieren</button>

      <pre id="classification-output" class="muted">// Klassifikation der Stickies erscheint hier…</pre>
    </div>
  </div>

  <script>
    // -----------------------------
    // Konfiguration Template 3-Boxes
    // -----------------------------
    const THREE_BOXES_TEMPLATE = {
      id: "datentreiber-3boxes",
      name: "Datentreiber 3-Boxes v1-1 (20240610)",
      imageUrl: "https://www.datentreiber.com/wp-content/uploads/2024/12/Datentreiber_EN_3-Boxes_v1-1_20240610.png",
      // Regions sind relativ (0–1) innerhalb des Bildes
      regions: [
        {
          id: "left",
          title: "Left Box",
          x0: 0.08,
          y0: 0.20,
          x1: 0.32,
          y1: 0.90,
        },
        {
          id: "middle",
          title: "Middle Box",
          x0: 0.37,
          y0: 0.20,
          x1: 0.62,
          y1: 0.90,
        },
        {
          id: "right",
          title: "Right Box",
          x0: 0.67,
          y0: 0.20,
          x1: 0.92,
          y1: 0.90,
        },
      ],
    };

    // State im Panel
    let currentTemplateImageId = null;
    let overlayItemIds = [];

    function setStatus(text) {
      const el = document.getElementById("status-line");
      if (el) el.textContent = text;
    }

    function formatJson(obj) {
      try {
        return JSON.stringify(obj, null, 2);
      } catch {
        return String(obj);
      }
    }

    // ----------------------------------
    // Template-Helper
    // ----------------------------------

    async function insertTemplateImage() {
      setStatus("Template wird eingefügt…");
      const image = await miro.board.createImage({
        url: THREE_BOXES_TEMPLATE.imageUrl,
        x: 0,
        y: 0,
        width: 1600, // Miro skaliert proportional
      });
      currentTemplateImageId = image.id;
      await populateTemplateSelect();
      setStatus("Template eingefügt (Image " + image.id + ").");
      await miro.board.viewport.zoomTo(image);
    }

    async function getTemplateImagesOnBoard() {
      const images = await miro.board.get({ type: "image" });
      return images.filter((img) => {
        // Miro speichert die URL ggf. leicht verändert, daher nur Prefix vergleichen
        return (
          typeof img.url === "string" &&
          img.url.startsWith(THREE_BOXES_TEMPLATE.imageUrl.split("?")[0])
        );
      });
    }

    async function populateTemplateSelect() {
      const select = document.getElementById("template-select");
      if (!select) return;

      const images = await getTemplateImagesOnBoard();
      select.innerHTML = "";
      if (!images.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "Kein Template-Image auf dem Board";
        select.appendChild(opt);
        currentTemplateImageId = null;
        return;
      }

      images.forEach((img, idx) => {
        const opt = document.createElement("option");
        opt.value = img.id;
        opt.textContent = `${THREE_BOXES_TEMPLATE.name} · image:${img.id} (#${idx + 1})`;
        if (!currentTemplateImageId) {
          currentTemplateImageId = img.id;
        }
        if (img.id === currentTemplateImageId) {
          opt.selected = true;
        }
        select.appendChild(opt);
      });
    }

    async function listTemplatesOnBoard() {
      const images = await getTemplateImagesOnBoard();
      if (!images.length) {
        alert("Kein 3-Boxes-Template auf diesem Board gefunden.");
        return;
      }
      currentTemplateImageId = images[0].id;
      await populateTemplateSelect();
      setStatus(images.length + " Template-Image(s) gefunden.");
    }

    async function getSelectedTemplateImage() {
      if (!currentTemplateImageId) {
        const select = document.getElementById("template-select");
        if (select && select.value) {
          currentTemplateImageId = select.value;
        }
      }
      if (!currentTemplateImageId) {
        const imgs = await getTemplateImagesOnBoard();
        if (imgs.length) {
          currentTemplateImageId = imgs[0].id;
        }
      }
      if (!currentTemplateImageId) {
        alert("Kein Template-Image ausgewählt. Bitte erst Template einfügen oder auswählen.");
        return null;
      }
      return await miro.board.getById(currentTemplateImageId);
    }

    async function zoomToTemplate() {
      const image = await getSelectedTemplateImage();
      if (!image) return;
      await miro.board.viewport.zoomTo(image);
    }

    async function toggleOverlay() {
      const output = document.getElementById("classification-output");

      // Wenn Overlays existieren -> entfernen
      if (overlayItemIds.length) {
        await miro.board.remove(overlayItemIds);
        overlayItemIds = [];
        setStatus("Areas-Overlay entfernt.");
        if (output) output.textContent = "// Overlay entfernt.";
        return;
      }

      const image = await getSelectedTemplateImage();
      if (!image) return;

      const imgLeft = image.x - image.width / 2;
      const imgTop = image.y - image.height / 2;

      const createdIds = [];
      for (const region of THREE_BOXES_TEMPLATE.regions) {
        const x0 = imgLeft + region.x0 * image.width;
        const y0 = imgTop + region.y0 * image.height;
        const w = (region.x1 - region.x0) * image.width;
        const h = (region.y1 - region.y0) * image.height;

        const shape = await miro.board.createShape({
          x: x0 + w / 2,
          y: y0 + h / 2,
          width: w,
          height: h,
          shape: "round_rectangle",
          content: `<p>${region.title}</p>`,
          style: {
            fillColor: "#f97316",     // orange
            fillOpacity: 0.06,
            borderColor: "#ea580c",
            borderOpacity: 0.7,
          },
        });
        createdIds.push(shape.id);
      }

      overlayItemIds = createdIds;
      setStatus("Areas-Overlay eingeblendet.");
      if (output) {
        output.textContent =
          "// Overlay eingeblendet für Template '" +
          THREE_BOXES_TEMPLATE.name +
          "'.";
      }
    }

    // ----------------------------------
    // Sticky-Klassifikation
    // ----------------------------------

    function classifyPoint(px, py) {
      if (px < 0 || px > 1 || py < 0 || py > 1) {
        return { inImageRect: false, region: null };
      }
      for (const region of THREE_BOXES_TEMPLATE.regions) {
        if (
          px >= region.x0 &&
          px <= region.x1 &&
          py >= region.y0 &&
          py <= region.y1
        ) {
          return { inImageRect: true, region };
        }
      }
      return { inImageRect: true, region: null };
    }

    async function classifyStickiesOnly() {
      const output = document.getElementById("classification-output");
      const image = await getSelectedTemplateImage();
      if (!image) {
        if (output) output.textContent = "// Kein Template-Image ausgewählt.";
        return null;
      }

      const imgLeft = image.x - image.width / 2;
      const imgTop = image.y - image.height / 2;

      const stickies = await miro.board.get({ type: "sticky_note" });

      const result = {
        template: {
          id: THREE_BOXES_TEMPLATE.id,
          name: THREE_BOXES_TEMPLATE.name,
          imageId: image.id,
        },
        counts: {
          total: stickies.length,
          byRegion: {},
        },
        items: [],
      };

      for (const s of stickies) {
        const cx = s.x;
        const cy = s.y;
        const px = (cx - imgLeft) / image.width;
        const py = (cy - imgTop) / image.height;

        const { inImageRect, region } = classifyPoint(px, py);

        const item = {
          stickyId: s.id,
          text: s.content ? s.plainText || s.content.replace(/<[^>]+>/g, "") : "",
          px: Number(px.toFixed(4)),
          py: Number(py.toFixed(4)),
          inImageRect,
          regionId: region ? region.id : null,
          regionTitle: region ? region.title : null,
        };

        if (region) {
          result.counts.byRegion[region.id] =
            (result.counts.byRegion[region.id] || 0) + 1;
        }

        result.items.push(item);
      }

      if (output) {
        output.textContent = formatJson(result);
      }

      return result;
    }

    // ----------------------------------
    // OpenAI / GPT
    // ----------------------------------

    async function callOpenAI({ apiKey, model, userText, classificationJson }) {
      const outEl = document.getElementById("openai-output");
      function log(msg) {
        if (outEl) outEl.textContent = msg;
      }

      if (!apiKey) {
        log("// Bitte OpenAI API Key eingeben.");
        return;
      }

      log("// Anfrage an OpenAI wird gesendet…");

      // Grundprompt – wenn Klassifikation vorhanden, mitverwenden
      let fullUserText = userText || "";
      if (classificationJson) {
        fullUserText =
          (userText || "Bitte analysiere die folgenden Sticky-Notizen.") +
          "\n\n=== STICKY-KLASSIFIKATION (JSON) ===\n" +
          classificationJson;
      }

      const body = {
        model,
        input: [
          {
            role: "system",
            content: [
              {
                type: "input_text",
                text:
                  "Du bist ein hilfreiches Analyse-Modell für Miro-Boards. " +
                  "Du erhältst optional JSON-Daten über Sticky-Notes auf einem Datentreiber-Template " +
                  "und sollst diese strukturiert analysieren.",
              },
            ],
          },
          {
            role: "user",
            content: [
              {
                type: "input_text",
                text: fullUserText,
              },
            ],
          },
        ],
        max_output_tokens: Number(
          document.getElementById("openai-max-tokens").value || "512"
        ),
      };

      try {
        const res = await fetch("https://api.openai.com/v1/responses", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(body),
        });

        const data = await res.json();
        if (!res.ok) {
          log(
            "Fehler: OpenAI request failed: " +
              res.status +
              "\n" +
              formatJson(data)
          );
          return;
        }

        // Responses-API: erste Antwort aus output[0].content[0]
        let text = "";
        const firstOut = data.output && data.output[0];
        if (
          firstOut &&
          Array.isArray(firstOut.content) &&
          firstOut.content[0] &&
          firstOut.content[0].type === "output_text"
        ) {
          text = firstOut.content[0].output_text.text;
        } else {
          text = formatJson(data);
        }

        log(text);
      } catch (err) {
        console.error(err);
        const msg =
          err && err.message ? String(err.message) : String(err || "Unknown");
        log("Fehler beim Aufruf der OpenAI API:\n" + msg);
      }
    }

    // ----------------------------------
    // Initialisierung & Event-Handler
    // ----------------------------------

    miro.onReady(async () => {
      setStatus("Panel geladen: " + new Date().toLocaleTimeString());

      await populateTemplateSelect();

      // Buttons holen
      const btnInsertTemplate = document.getElementById("btn-insert-template");
      const btnListTemplates = document.getElementById("btn-list-templates");
      const btnZoomTemplate = document.getElementById("btn-zoom-template");
      const btnToggleOverlay = document.getElementById("btn-toggle-overlay");
      const btnClassify = document.getElementById("btn-classify-stickies");

      const btnOpenAiSend = document.getElementById("btn-openai-send");
      const btnOpenAiSendWithStickies = document.getElementById(
        "btn-openai-send-with-stickies"
      );

      const selectTemplate = document.getElementById("template-select");

      if (selectTemplate) {
        selectTemplate.addEventListener("change", () => {
          currentTemplateImageId = selectTemplate.value || null;
        });
      }

      if (btnInsertTemplate) {
        btnInsertTemplate.onclick = insertTemplateImage;
      }
      if (btnListTemplates) {
        btnListTemplates.onclick = listTemplatesOnBoard;
      }
      if (btnZoomTemplate) {
        btnZoomTemplate.onclick = zoomToTemplate;
      }
      if (btnToggleOverlay) {
        btnToggleOverlay.onclick = toggleOverlay;
      }
      if (btnClassify) {
        btnClassify.onclick = classifyStickiesOnly;
      }

      if (btnOpenAiSend) {
        btnOpenAiSend.onclick = async () => {
          const apiKey = document.getElementById("openai-key").value.trim();
          const model = document.getElementById("openai-model").value;
          const userText =
            document.getElementById("openai-user-message").value.trim();
          await callOpenAI({ apiKey, model, userText, classificationJson: null });
        };
      }

      if (btnOpenAiSendWithStickies) {
        btnOpenAiSendWithStickies.onclick = async () => {
          const apiKey = document.getElementById("openai-key").value.trim();
          const model = document.getElementById("openai-model").value;
          const userText =
            document.getElementById("openai-user-message").value.trim();
          const classification = await classifyStickiesOnly();
          const classificationJson = classification
            ? formatJson(classification)
            : null;
          await callOpenAI({
            apiKey,
            model,
            userText,
            classificationJson,
          });
        };
      }
    });
  </script>
</body>
</html>
